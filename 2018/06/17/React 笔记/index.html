<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Cara"><title>React 笔记 · Cara's Blog</title><meta name="description" content="学习 React 已经是很早就有的想法了, 因为之前的工作一直接触的都是 Vue.js 并且知道它俩的有异曲同工之妙, 但在写法上还是有蛮大区别的. 在提到 Vue 的地方也总是伴随着 React 像是麦当劳和肯德基一样(加上现在的前端都要怀揣一两个框架傍身🤷‍), 其实兴趣还挺大的, 但是在工作"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="http://ordjgqxuv.bkt.clouddn.com/nike-girl/IMG_2930.JPG" style="width:127px;"><h3 title=""><a href="/">Cara's Blog</a></h3></div></div><ul class="social-links"></ul><div class="footer"></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li><li><a href="/about">关于</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>React 笔记</a></h3></div><div class="post-content"><p>学习 React 已经是很早就有的想法了, 因为之前的工作一直接触的都是 <code>Vue.js</code> 并且知道它俩的有异曲同工之妙, 但在写法上还是有蛮大区别的. 在提到 <code>Vue</code> 的地方也总是伴随着 <code>React</code> 像是麦当劳和肯德基一样(加上现在的前端都要怀揣一两个框架傍身🤷‍), 其实兴趣还挺大的, 但是在工作和准备跳槽等琐事下一直耽误. 到最近才有一些时间跟着文档写一点小 demo 入门 <a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">React 16.2.0</a> , 顺便记录一下学习过程.</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>直接使用 <code>create-react-app</code>, 这个过程想必大家都很熟悉了就不再说. 等待安装完成之后, 就成功启动了第一个 react 项目. 看一眼项目结构, 呃… 这么简洁的吗?</p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>默认的结构非常简洁, 简单到怀疑是不是自己哪里搞错了…</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">react-srart</span><br><span class="line">  - node-modules/</span><br><span class="line">  - public/</span><br><span class="line">  - src/</span><br><span class="line">  - .gitignore</span><br><span class="line">  - package.json</span><br><span class="line">  - README.md</span><br><span class="line">  - yarn.lock</span><br></pre></td></tr></table></figure>
<p>可以发现没有看到 <code>webpack</code> 的配置, 查了一波原来是被隐藏掉了. 打开 <code>package.json</code>:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"script": &#123;</span><br><span class="line">  "eject": "react-scripts eject"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们运行这条命令 <code>yarn eject</code>, 在终端就可以看到以下输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">➜  react-start git:(master) ✗ yarn eject</span><br><span class="line">yarn run v1.7.0</span><br><span class="line"><span class="meta">$</span> react-scripts eject</span><br><span class="line">? Are you sure you want to eject? This action is permanent. Yes</span><br><span class="line">Ejecting...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> config 和 script 两个文件夹</span><br><span class="line">Copying files into /Users/cara/workspace/project/react-staff/react-start</span><br><span class="line">  Adding /config/env.js to the project</span><br><span class="line">  Adding /config/paths.js to the project</span><br><span class="line">  Adding /config/polyfills.js to the project</span><br><span class="line">  Adding /config/webpack.config.dev.js to the project</span><br><span class="line">  Adding /config/webpack.config.prod.js to the project</span><br><span class="line">  Adding /config/webpackDevServer.config.js to the project</span><br><span class="line">  Adding /config/jest/cssTransform.js to the project</span><br><span class="line">  Adding /config/jest/fileTransform.js to the project</span><br><span class="line">  Adding /scripts/build.js to the project</span><br><span class="line">  Adding /scripts/start.js to the project</span><br><span class="line">  Adding /scripts/test.js to the project</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 添加了依赖项 (太多就省略了)</span><br><span class="line">Updating the dependencies</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 替换 package.json 里的命令</span><br><span class="line">Updating the scripts</span><br><span class="line">  Replacing "react-scripts start" with "node scripts/start.js"</span><br><span class="line">  Replacing "react-scripts build" with "node scripts/build.js"</span><br><span class="line">  Replacing "react-scripts test" with "node scripts/test.js"</span><br><span class="line"></span><br><span class="line">Configuring package.json</span><br><span class="line">  Adding Jest configuration</span><br><span class="line">  Adding Babel preset</span><br><span class="line">  Adding ESLint configuration</span><br><span class="line"></span><br><span class="line">Ejected successfully!</span><br><span class="line"></span><br><span class="line">Please consider sharing why you ejected in this survey:</span><br><span class="line">  http://goo.gl/forms/Bi6CZjk1EqsdelXk1</span><br><span class="line"></span><br><span class="line">✨  Done in 2.20s.</span><br></pre></td></tr></table></figure>
<p>接着项目目录中就多了两个文件夹, <code>scripts</code> 和 <code>config</code> 又看到了我们熟悉的 <code>webpack</code> 的配置, 同时 <code>package.json</code> 也发生一些变化.</p>
<h4 id="React-基本"><a href="#React-基本" class="headerlink" title="React 基本"></a>React 基本</h4><p>知道了如何创建新的项目, 接下来该了解一下 <code>React</code> 的基本 API 和 生命周期了. 在 React 的世界里一切皆函数, 使用的 <code>JSX</code> 一种 JavaScript 的扩展语法. 下面来看一下 JSX 的基本用法</p>
<ul>
<li>JSX 中嵌入表达式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> formatString = <span class="function">(<span class="params">name, type</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> name + <span class="string">' frist '</span> + type + <span class="string">'appliction!'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123; formatString(<span class="string">'cara'</span>, <span class="string">'React'</span>) &#125;</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  element,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JSX 作为表达式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createElement = <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;formatString('cara', 'React')&#125;&lt;/h1&gt;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;Hello, Stranger&lt;/h1&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>JSX 在指定属性时, 必须使用驼峰命名, 表达式通过花括号计算</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> image = &lt;img src=&#123;user.avatarImg&#125; /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>JSX 也可以包含子元素</li>
</ul>
<blockquote>
<p>React 在多次渲染同一个组件时, 不会这个销毁再重新渲染, 而是只更新需要更新的部分.</p>
</blockquote>
<h5 id="Components-和-Props"><a href="#Components-和-Props" class="headerlink" title="Components 和 Props"></a>Components 和 Props</h5><p><strong> 函数式组件(无状态)和类组件 </strong></p>
<p>一个有效的函数式组件, 可以接收一个 props 并返回一个 React 元素. 因为它本身长的就很像函数, 所以称之为函数式组件.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数式组件</span></span><br><span class="line"><span class="keyword">const</span> Welcome = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数式组件也是无状态组件, 无状态组件可以很方便的通过组合构建为其他组件, 只带有一个 render 返回组件没有 <code>state</code> 状态.<br>无状态组件被鼓励在大型的项目中将组件尽量的分割原本大型的组件.</p>
<p>它的特点:</p>
<ul>
<li>精简, 可读性高</li>
<li>组件不会实例化, 减少内存, 提高渲染性能</li>
<li>组件不能访问 <code>this</code>(因为没有实例化)</li>
<li>不能使用生命周期方法(因为无状态)</li>
<li>只能传入 props, 没有副作用</li>
</ul>
<p>也可以用 ES6 中的 Class 来定义一个组件(React.Component), 也是 React 推荐的创建有状态组价的方式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="comment">// 初始化 state</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      text: <span class="keyword">this</span>.props.initText || <span class="string">'placeholder'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 类函数必须手动绑定</span></span><br><span class="line">    <span class="keyword">this</span>.handleTextChange = <span class="keyword">this</span>.handleTextChange.bind(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleTextChange (e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      text: e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;input</span><br><span class="line">        type="text"</span><br><span class="line">        onChange=&#123;this.handleTextChange&#125;</span><br><span class="line">        value=&#123;this.state.text&#125; /&gt;</span><br><span class="line">        &#123;this.state.text&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React.Component 创建的组件不会自动绑定 <code>this</code>, 需要我们手动绑定, 否则事件处理程序不能通过 <code>this</code> 获取当前组件的实例对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetThis</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;button onClick=&#123;this.handleClick&#125;&gt;&lt;/button&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手动绑定 <code>this</code> 的方式:</p>
<ul>
<li>在构造函数中绑定</li>
<li>使用时通过 <code>method.bind(this)</code> 绑定</li>
<li>调用时使用箭头函数</li>
</ul>
<p><code>this.props</code> 可以获取到从组件外层传入的自定义属性, 跟 Vue 组件内部的 <code>props</code> 类似.</p>
<blockquote>
<p>注意: 组件的名称都以大写字母开头, 属性名使用驼峰命名; 组件中跟 Vue 一样都需要一个根节点.</p>
</blockquote>
<p><strong> 提取组件 </strong><br>react 中提倡把一个组件拆分成多个小组件便于复用, 尤其是 UI 组件. 我理解的是因为 React 一切皆函数, 具体到 <code>button</code> 这种小的 UI 组件, 每次都重写一遍就很没意义, 所以尽量拆小一点以便复用. 官网中以评论框为例, 这里就不再复述.</p>
<p><strong> Props 是只读的</strong><br>在 React 中有一条非常严格的规则: 所有 React 的组件都必须是纯函数, 不得改变自身组件的 props. (纯函数是指: 不会改变参数的输入, 对于相同的输入始终可以得到相同的结果) 看到官网这么说我也很疑惑 UI 组件不可能都是纯的静态组件啊, 肯定有根据状态动态改变视图的, 或者做一些过滤和格式化的操作. 于是来到状态和生命周期</p>
<blockquote>
<p>react 写 html 标签在 vscode 中使用 emmet 自动补全需要如下配置:</p>
</blockquote>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"emmet.includeLanguages": &#123;</span><br><span class="line">  "javascript": "javascriptreact"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="State-和生命周期"><a href="#State-和生命周期" class="headerlink" title="State 和生命周期"></a>State 和生命周期</h5><p>state 和 props 类似都在组件内部由组件自己维护, 可以说是组件自身的一个局部状态吧. 举例说明:</p>
<p>我们需要一个在内部自动更新的组件, 在内部维护自己的状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 React.Component 继承一个 Clack 类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clack</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 始终使用 props 调用构造函数</span></span><br><span class="line">  <span class="comment">// 初始化 state</span></span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="comment">// 类似于 Vue 中的 data</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;State Component&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;Time is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在我们有了一个有着局部状态的类组件, 接下来让 Clack 设置自己的计时器, 两秒更新一次.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clack</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件第一次挂载到 DOM 时(钩子)</span></span><br><span class="line">  componentDidMount () &#123;</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">_</span> =&gt;</span> <span class="keyword">this</span>.ticker(), <span class="number">2000</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件被销毁时(钩子)</span></span><br><span class="line">  componentWillUnmount () &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timer)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ticker () &#123;</span><br><span class="line">    <span class="comment">// 更新 state</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div&gt;State Component&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;Time is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>于是在 Clack 组件第一次被挂载到 DOM 时, 通过 <code>componentDidMount</code> 生命周期钩子调用一个定时器, <code>setState</code> 改变组件状态来达到定时更新时间; 而在组件销毁时通过 <code>componentWillMount</code> 钩子来停止定时器.</p>
<p><strong>组件的生命周期</strong><br>组件的生命周期分为三大类: <code>Mounting</code>(装载时); <code>updating</code>(更新); <code>unmounting</code>(卸载时). 跟 Vue 一样你可以在钩子函数里运行一些特定的代码.</p>
<ol>
<li><p>Mounting(装载): 当组件实例创建且插入 DOM 时, 下面的方法将会被调用</p>
<ul>
<li><p>constructor()<br>初始化 props/ state 或者绑定事件处理程序</p>
</li>
<li><p>componentWillMount()</p>
</li>
<li><p>render()<br>通常用来返回 React 元素(数字/字符/portals/null: 不渲染/布尔值:不渲染任何东西) 且应该是纯函数, 注意当 <code>shouldComponentUpdate()</code> 返回 false 时, render 不会被调用.</p>
</li>
<li><p>componentDidMount()<br>在组件装载后立即调用, 等同于 Vue 的 mounted(). 在这个函数中使用 <code>setState()</code> 会触发两次 render(但不会被用户感知).</p>
</li>
</ul>
</li>
<li><p>Updating(更新): 当 props 和 state 发生改变, 重新渲染组件会触发以下钩子</p>
<ul>
<li><p>componentWillReceiveProps(nextProps)<br><code>componentWillReceiveProps(nextProps)</code> 在响应 props 变化之前被调用. 有个注意点是有可能 props 没有更新 React 也调用了这个函数, 所以如果你只关心变化需要自己比较当前值和下一个值.</p>
</li>
<li><p>shouldComponentUpdate(nextProps, nextState)<br>组件是否受 props 和 state 变化的影响, 默认返回 true. 首次渲染或使用 <code>forceUpdate()</code> 时不调用此方法;  如果 <code>shouldComponentUpdate()</code> 返回 false, 那么 <code>componentWillUpdate()</code>, <code>render()</code> 和 <code>componentDidUpdate()</code> 将不会调用. 所以你可以手动返回 false 告诉 React 这次不必更新, 另外不要在这里进行深度检查(如: 深拷贝) 会非常消耗性能.</p>
</li>
<li><p>componentWillUpdate(nextProps, nextState)<br>该函数在第一次渲染时不会被调用, 会在收到 <code>nextProps</code> 或 <code>nextState</code> 之后在更新渲染之前被立即调用. 需要主要注意的是这里不能使用 <code>setState()</code>, 如果需要用 state 响应 props 的变化, 改用 <code>componentWillReceiveProps()</code>.</p>
</li>
<li><p>render()</p>
</li>
<li><p>componentDidUpdate(prevProps, prevState)<br>第一次渲染时不会调用, 在更新发生后立即被调用</p>
</li>
</ul>
</li>
<li><p>Unmounting(卸载): 组件从 DOM 上删除</p>
<ul>
<li>componentWillUnmount()<br>在组件被卸载或者销毁之前调用, 在这里通常用来取消一些订阅.</li>
</ul>
</li>
</ol>
<p>个人觉得 React 的生命周期钩子名字要比 Vue 的好理解一点, 起码一看名字就知道是啥.</p>
<p><strong>其他 API</strong></p>
<ul>
<li><p>setState(): 只是一个请求而不是立即命令来更新组件, 所以并不总是立即更新. 如果需要在 <code>setState()</code> 之后立即读取 <code>this.state</code>, 需要使用 <code>componentDidUpdate</code> 或者 <code>setState(updater, callback)</code>.(setState() 的第一个参数可以是对象, 也可以是函数)</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为对象</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>: <span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数为函数会保证 prevState, props 是最新的, 第二个参数是可选的 callback</span></span><br><span class="line"><span class="comment">// callback 会在 setState 完成后执行并重新渲染组件</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">count</span>: prevState.count + props.increment &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用到 callback 的话, 建议使用 componentDidUpdate()</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>defaultProps: 为类设置默认的 props.<br>使用下面的组件时不传入 <code>props.color</code>, 他就会被设置为 <code>&#39;blue&#39;</code>. 如果被手动设置为 null 那它会保持为 null</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ball</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Ball.defaultProps = &#123;</span><br><span class="line">  color: <span class="string">'blue'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在其他地方使用时, color 将保持为 null</span></span><br><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;Ball color=&#123;null&#125; /&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>state 的注意事项</strong></p>
<ul>
<li>state 是组件内部的状态, 如果不在 <code>render()</code> 中使用那它就不应该是 <code>state</code>. 永远不要直接改变 <code>state</code></li>
<li>数据向下流动, 一个组件的 state 可以向下传递作为子组件的 props, 也就是常说的单向数据流.</li>
</ul>
<p>created on 2018-06-18</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2018-06-17</span><i class="fa fa-tag"></i><a href="/categories/笔记📒/" title="笔记📒" class="tag">笔记📒 </a><a href="/tags/JavaScript/" title="JavaScript" class="tag">JavaScript </a><a href="/tags/React/" title="React" class="tag">React </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,https://yoursite.com/2018/06/17/React 笔记/,Cara's Blog,React 笔记,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a role="navigation" href="/2018/05/06/网络摄像机直播/" title="网络摄像机直播" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>