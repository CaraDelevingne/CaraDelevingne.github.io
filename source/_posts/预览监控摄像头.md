---
title: ' 预览监控摄像头'
date: 2017-10-15 18:49:04
tags:
- JavaScript
- Node.js
categories:
- 笔记📒
---

> 现目前用过三种方案, 都不完美. 以下说的是很早之前的方案, 之后有空再重新写这篇.



在预览摄像头监控画面时, 用 `WebSocket` 发送 RTSP 实时视频流. 在浏览器中接收到是一堆 bytes, 所以需要转化为 blob 类型或者 base64 给canvas 渲染出来.

> ### 1. Node端
当时用的是一个个人项目`rtsp-ffmpeg` [链接](https://github.com/agsh/rtsp-ffmpeg), 有空的话可以看看`WebRTC`

- 安装FFMPEG [FFMPEG下载](http://ffmpeg.zeranoe.com/builds/)
- 解压后, 在C盘根目录下创建文件夹ffmpeg, 将解压文件放入
- 设置环境变量, windows下在我的电脑 -> 属性 -> 高级系统设置 -> 环境变量 -> 系统变量 -> 新增
在刚刚ffmpeg的路径上具体到文件夹中的bin文件夹
- 测试, 在命令行中输入`ffmpeg -version` 出现版本号啥的就安装成功 (如果不行的话, 注销电脑让环境变量生效)

> ### 2. 利用`socket.io`向浏览器发送视频数据
关键代码: 
```javascript
 var rtsp = require('rtsp-ffmpeg');
 // 推流
 var uri = 'rtsp://accout:password@ip:port/h264/ch1/main/av_stream',
     stream = new rtsp.FFMpeg({
         input: uri,
         rate: 10,
         resolution: '320x240',
         quality: 3
     });

 var cameraInfo = {}
 // 连接时
 io.on('connection', socket => {
     console.log('connection')
     var pipeStream = function(data) {
         socket.emit('data', data);
     };
     stream.on('data', pipeStream);
     socket.on('URI', data => {
         console.log(data);
         cameraInfo.cameraName = data.cameraName;
         cameraInfo.groupName = data.groupName;
         uri = `rtsp://${data.userName}:${data.passWord}@${data.ip}:${data.RTSP}/h264/ch1/main/av_stream`;
         stream.input = uri;
         stream.restart();
         socket.emit('CameraInfo', cameraInfo);
     })
     // 断开连接
     socket.on('disconnect', function() {
         stream.removeListener('data', pipeStream);
     });
 })
```

中间将`Node.js`托管到IIS服务器上时会出现跨域的报错, 可能是和后端连接时端口被占, 具体看IIS报什么错. 如果IIS没报错, 还是有跨域的话可能还是`ffmpeg`没安装上.

如果用canvas预览摄像头还是有花屏的情况, 可以将码流切换为子码流`rtsp://accout:password@ip:port/h264/ch1/sub/av_stream`

> ### 3. 浏览器
基于`Vue.js`, 先引入`socket.io`并建立连接, 然后对视频流数据做处理(展示时不要用`img`标签, 掉帧比较严重).

关键代码: 
```JavaScript
var bytes = new Uint8Array(data);
					
var blob = new Blob([bytes], {type: 'application/octet-binary'});
                
var url = URL.createObjectURL(blob);
                
var img = new Image;
                
var ctx = this.canvas.getContext("2d");
    img.width = img.width * 0.5;
    img.height = img.height * 0.5;
    img.onload = function() {
         URL.revokeObjectURL(url);
         ctx.drawImage(img, 0, 0,720,560);
    };    
img.src = url;
```

Created on 2017/7/26 by Cara
