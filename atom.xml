<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cara&#39;s Blog</title>
  
  <subtitle>Do what you like , Like what you do.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2018-06-18T15:40:04.651Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>Cara</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络摄像机直播</title>
    <link href="https://yoursite.com/2018/05/06/%E7%BD%91%E7%BB%9C%E6%91%84%E5%83%8F%E6%9C%BA%E7%9B%B4%E6%92%AD/"/>
    <id>https://yoursite.com/2018/05/06/网络摄像机直播/</id>
    <published>2018-05-06T06:49:04.000Z</published>
    <updated>2018-06-18T15:40:04.651Z</updated>
    
    <content type="html"><![CDATA[<p>对于网络摄像机做视频预览这块, 本身其实是非常陌生的, 当时接到这个需求也是相当的头疼(对于当时一年经验不到的我来说).当时我们的应用场景是: 多路网络摄像机通过局域网连接, PC 端能够实时预览监控画面并且画质达到720p, 延迟不能超过10秒, 多个摄像机能够切换查看. 由于后端只提供一个 RTSP 的直播协议, 所以所有的方案都是围绕着 RTSP 这个关键词.</p><blockquote><p> 当时时间很赶所以要自己慢慢研究是不可能了, 只能去找现成的库. 现目前用过三种方案, 都不完美.</p></blockquote><h3 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h3><p>经过一波调研(google)之后, 知道浏览器对 RTSP 协议并不友好, 也就是说我们必须要自己转码再提供给浏览器使用, 找到的解决思路大概是:</p><ol><li>转码: <a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a> 是一个老牌的转码工具, 非常强大</li><li>Node.js 用作中转站接收客户端发来的摄像机信息及控制 FFmpeg 推流</li><li>最终客户端接收视频流</li></ol><p>下面我试过的三种方案, 基本结构都如此只是推流的方式和客户端的接收方式有所不同.</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p><strong>安装 FFmpeg 转码工具</strong></p><ul><li>window 平台</li></ul><ol><li><a href="http://ffmpeg.zeranoe.com/builds/" target="_blank" rel="noopener">下载 FFmpeg</a> 解压后应该是已经编译好的文件</li><li>将解压好的文件放入 C 盘根目录(也可以自行放入其他盘符)下重命名为 ffmpeg(方便以后找)</li><li>设置环境变量, 我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; 新增, 路径选择刚刚 C 盘下的 ffmpeg文件夹中的 bin 文件夹</li><li>注销或重启电脑让环境变量生效</li><li>测试, 在 cmd 中输入 <code>ffmpeg -version</code>,  如果出现版本号之类的东西则成功.</li></ol><ul><li>Mac 平台<br>Mac 下可以直接通过 <code>Homebrew</code> 安装最为简单.</li></ul><ol><li>安装 <code>Homebrew</code>, 在终端中输入 <code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></li><li>安装 FFmpeg, 直接在终端中输入 <code>brew install ffmpeg</code> 即可</li><li>测试, 同样在终端中输入 <code>ffmpeg -version</code> 查看版本号</li></ol><p><strong>安装 Node.js</strong><br>这个就不展开详细说了, 每个前端都有吧…</p><h3 id="方案一-img-标签"><a href="#方案一-img-标签" class="headerlink" title="方案一: img 标签"></a>方案一: img 标签</h3><p>当时想到的第一种方案也是最简单的方案, 是将视频流的每一帧转化为 base64 再通过动态替换 <code>&lt;img&gt;</code> 的 src 属性来达到预览的效果.中间用到了<a href="https://github.com/agsh/rtsp-ffmpeg" target="_blank" rel="noopener">rtsp-ffmpeg</a>, 这个库的思路是通过 websocket 发送每一帧视频的 bytes 到客户端, 客户端可以通过 <code>&lt;img&gt;</code> 标签来展示.</p><p><strong>示例:</strong></p><p>node 端<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)()</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app)</span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server)</span><br><span class="line"><span class="keyword">const</span> rtsp = <span class="built_in">require</span>(<span class="string">'rtsp-ffmpeg'</span>)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8081</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server listening on 8081'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// uri 以海康摄像机的 rtsp 协议为例</span></span><br><span class="line"><span class="keyword">let</span> uri = <span class="string">'rtps://admin:password@ip:port/h264/ch1/sub/av_stream'</span></span><br><span class="line"><span class="keyword">let</span> stream = <span class="keyword">new</span> rtsp.FFMpeg(&#123;</span><br><span class="line">    input: uri,</span><br><span class="line">    resolution: <span class="string">'1080x720'</span>,</span><br><span class="line">    quality: <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'start'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stream'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'stop'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stream stopped'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> pipeStream = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        socket.emit(<span class="string">'data'</span>, data)</span><br><span class="line">    &#125;</span><br><span class="line">    stream.on(<span class="string">'data'</span>, pipeStream)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换摄像机</span></span><br><span class="line">    socket.on(<span class="string">'URI'</span>, data =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">        uri = <span class="string">`rtsp://<span class="subst">$&#123;data.userName&#125;</span>:<span class="subst">$&#123;data.passWord&#125;</span>@<span class="subst">$&#123;data.ip&#125;</span>:<span class="subst">$&#123;data.port&#125;</span>/h264/ch1/sub/av_stream`</span></span><br><span class="line">        stream.input = uri</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重启</span></span><br><span class="line">        stream.restart()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'disconnect'</span> () =&gt; &#123;</span><br><span class="line">        stream.removeListener(<span class="string">'data'</span>, pipeStream)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>客户端<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">'img'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'/socket.io/socket.io.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> io = io();</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> img = <span class="built_in">document</span>.querySelector(<span class="string">'#img'</span>)</span></span><br><span class="line"><span class="javascript">io.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> bytes = <span class="keyword">new</span> Unit8Array(data)</span></span><br><span class="line"><span class="javascript">        img.src = <span class="string">'data:image/jpeg;base64,'</span> + base64ArrayBuffer(bytes)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// byte 数组转 base64 (这段是在其他地方抄的)</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">base64ArrayBuffer</span>(<span class="params">arrayBuffer</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> base64    = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> encodings = <span class="string">'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> bytes         = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(arrayBuffer);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> byteLength    = bytes.byteLength;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> byteRemainder = byteLength % <span class="number">3</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> mainLength    = byteLength - byteRemainder;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> a, b, c, d;</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> chunk;</span></span><br><span class="line"><span class="javascript"><span class="comment">// Main loop deals with bytes in chunks of 3</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; mainLength; i = i + <span class="number">3</span>) &#123;</span></span><br><span class="line"><span class="javascript"><span class="comment">// Combine the three bytes into a single integer</span></span></span><br><span class="line"><span class="undefined">chunk = (bytes[i] &lt;&lt; 16) | (bytes[i + 1] &lt;&lt; 8) | bytes[i + 2];</span></span><br><span class="line"><span class="javascript"><span class="comment">// Use bitmasks to extract 6-bit segments from the triplet</span></span></span><br><span class="line"><span class="javascript">a = (chunk &amp; <span class="number">16515072</span>) &gt;&gt; <span class="number">18</span>; <span class="comment">// 16515072 = (2^6 - 1) &lt;&lt; 18</span></span></span><br><span class="line"><span class="javascript">b = (chunk &amp; <span class="number">258048</span>)   &gt;&gt; <span class="number">12</span>; <span class="comment">// 258048   = (2^6 - 1) &lt;&lt; 12</span></span></span><br><span class="line"><span class="javascript">c = (chunk &amp; <span class="number">4032</span>)     &gt;&gt;  <span class="number">6</span>; <span class="comment">// 4032     = (2^6 - 1) &lt;&lt; 6</span></span></span><br><span class="line"><span class="javascript">d = chunk &amp; <span class="number">63</span>;               <span class="comment">// 63       = 2^6 - 1</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// Convert the raw binary segments to the appropriate ASCII encoding</span></span></span><br><span class="line"><span class="undefined">base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">// Deal with the remaining bytes and padding</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (byteRemainder == <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="undefined">chunk = bytes[mainLength];</span></span><br><span class="line"><span class="javascript">a = (chunk &amp; <span class="number">252</span>) &gt;&gt; <span class="number">2</span>; <span class="comment">// 252 = (2^6 - 1) &lt;&lt; 2</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// Set the 4 least significant bits to zero</span></span></span><br><span class="line"><span class="javascript">b = (chunk &amp; <span class="number">3</span>)   &lt;&lt; <span class="number">4</span>; <span class="comment">// 3   = 2^2 - 1</span></span></span><br><span class="line"><span class="javascript">base64 += encodings[a] + encodings[b] + <span class="string">'=='</span>;</span></span><br><span class="line"><span class="javascript">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (byteRemainder == <span class="number">2</span>) &#123;</span></span><br><span class="line"><span class="undefined">chunk = (bytes[mainLength] &lt;&lt; 8) | bytes[mainLength + 1];</span></span><br><span class="line"><span class="javascript">a = (chunk &amp; <span class="number">64512</span>) &gt;&gt; <span class="number">10</span>; <span class="comment">// 64512 = (2^6 - 1) &lt;&lt; 10</span></span></span><br><span class="line"><span class="javascript">b = (chunk &amp; <span class="number">1008</span>)  &gt;&gt;  <span class="number">4</span>; <span class="comment">// 1008  = (2^6 - 1) &lt;&lt; 4</span></span></span><br><span class="line"><span class="javascript"><span class="comment">// Set the 2 least significant bits to zero</span></span></span><br><span class="line"><span class="javascript">c = (chunk &amp; <span class="number">15</span>)    &lt;&lt;  <span class="number">2</span>; <span class="comment">// 15    = 2^4 - 1</span></span></span><br><span class="line"><span class="javascript">base64 += encodings[a] + encodings[b] + encodings[c] + <span class="string">'='</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">return</span> base64;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这种通过 img 的方式暴露出的问题是需要在前端解码, 导致下一帧到来时上一帧的画面还没解码完成. 就会有花屏甚至画面只显示一半的问题和延迟较大且延迟会累积, 在控制台中你会看到疯狂刷从内存来的请求, 如果你想看看 http 请求可能会疯. 所以这种方式肯定不行</p><p>这个 <code>rtsp-ffmpeg</code> 还提供一种 canvas 的方式, 只是在客户端做一些修改:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> io = io();</span><br><span class="line"><span class="comment">// 把之前的 img 标签换成 canvas</span></span><br><span class="line"><span class="keyword">let</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'#canvas'</span>)</span><br><span class="line">io.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> bytes = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([bytes], &#123;<span class="attr">type</span>: <span class="string">'application/octet-binary'</span>&#125;)</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">var</span> url = URL.createObjectURL(blob)</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image</span><br><span class="line">                    </span><br><span class="line">    <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">"2d"</span>)</span><br><span class="line">        img.width = img.width * <span class="number">0.5</span></span><br><span class="line">        img.height = img.height * <span class="number">0.5</span></span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            URL.revokeObjectURL(url)</span><br><span class="line">            ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1080</span>, <span class="number">720</span>)</span><br><span class="line">        &#125;;    </span><br><span class="line">    img.src = url</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>用 canvas 的方法虽然比 img 的效果好一点, 但是最终效果仍然是不尽人意. 图像很不稳定, 表现为一半画面一半绿屏, 如果视频中图像变换剧烈的话表现会更差, 所以这种方法也不太行. 其实在这中间我并没有做什么操作只是将这个 demo 集成在了 vue 中, 再加上多摄像机的切换和主流摄像机厂商的支持(因为每个摄像机厂商的 rtsp 协议的结构不一样)而已, 所以第一想法是能不能在解码这块找到更好解决办法, 于是又找到了另一个库 <a href="https://github.com/phoboslab/jsmpeg" target="_blank" rel="noopener">jsmpeg</a> 方案二就来了.</p><h3 id="方案二-jsmpeg"><a href="#方案二-jsmpeg" class="headerlink" title="方案二: jsmpeg"></a>方案二: jsmpeg</h3><p>这个库还算比较不错的了, 也是通过 websocket 来转发, 看官方的例子是在终端中启动 ffmpeg -&gt; websocket -&gt; 客户端通过 <code>jsmpeg.min.js</code> 解码在 canvas 中播放. 因为这里只是实现了播放, 在这个基础上我们还需要在脚本中自启 ffmpeg / 切换/ 重启, 然后又去找了一个基于 <code>jsmpeg</code> 的库 <a href="https://github.com/kyriesent/node-rtsp-stream" target="_blank" rel="noopener">node-rtsp-stream</a>. 这个库只是做了一些封装让我们不用自己在终端中手动启用 ffmpeg, 在此之上我再加上重启就能满足现在的需求.</p><p><strong>示例:</strong></p><ol><li>改造 <code>node-rtsp-stream</code></li></ol><p>node-rtsp-stream/videoStream.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Mpeg1Muxer, STREAM_MAGIC_BYTES, VideoStream, events, util, ws;</span><br><span class="line"></span><br><span class="line">    ws = <span class="built_in">require</span>(<span class="string">'ws'</span>);</span><br><span class="line"></span><br><span class="line">    util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">    events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line">    Mpeg1Muxer = <span class="built_in">require</span>(<span class="string">'./mpeg1muxer'</span>);</span><br><span class="line"></span><br><span class="line">    STREAM_MAGIC_BYTES = <span class="string">"jsmp"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line">    VideoStream = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = options.name;</span><br><span class="line">        <span class="keyword">this</span>.streamUrl = options.streamUrl;</span><br><span class="line">        <span class="keyword">this</span>.width = options.width;</span><br><span class="line">        <span class="keyword">this</span>.height = options.height;</span><br><span class="line">        <span class="keyword">this</span>.wsPort = options.wsPort;</span><br><span class="line">        <span class="keyword">this</span>.inputStreamStarted = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.stream = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.startMpeg1Stream();</span><br><span class="line">        <span class="keyword">this</span>.pipeStreamToSocketServer();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    util.inherits(VideoStream, events.EventEmitter);</span><br><span class="line">    <span class="comment">// 停止视频流</span></span><br><span class="line">    VideoStream.prototype.stop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mpeg1Muxer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mpeg1Muxer.stream.stop()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重启视频流</span></span><br><span class="line">    VideoStream.prototype.restart = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mpeg1Muxer) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mpeg1Muxer.stream.stop()</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ffmpeg is restart'</span>)</span><br><span class="line">            <span class="keyword">this</span>.inputStreamStarted = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">this</span>.stream = <span class="keyword">void</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.startMpeg1Stream();</span><br><span class="line">            <span class="comment">// 监听 ffmpeg 进程是否关闭</span></span><br><span class="line">            <span class="keyword">this</span>.mpeg1Muxer.on(<span class="string">'ffmpegClose'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'ffmpeg closed on '</span> + code)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    VideoStream.prototype.startMpeg1Stream = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 省略打开流的方法, 这部分没有做改动</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    VideoStream.prototype.pipeStreamToSocketServer = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 将流塞给 socket, 同样也没改</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    VideoStream.prototype.onSocketConnect = <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self, streamHeader;</span><br><span class="line">        self = <span class="keyword">this</span>;</span><br><span class="line">        streamHeader = <span class="keyword">new</span> Buffer(<span class="number">8</span>);</span><br><span class="line">        streamHeader.write(STREAM_MAGIC_BYTES);</span><br><span class="line">        streamHeader.writeUInt16BE(<span class="keyword">this</span>.width, <span class="number">4</span>);</span><br><span class="line">        streamHeader.writeUInt16BE(<span class="keyword">this</span>.height, <span class="number">6</span>);</span><br><span class="line">        socket.send(streamHeader, &#123;</span><br><span class="line">            binary: <span class="literal">true</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log((<span class="string">""</span> + <span class="keyword">this</span>.name + <span class="string">": New WebSocket Connection ("</span>) + <span class="keyword">this</span>.wsServer.clients.length + <span class="string">" total)"</span>);</span><br><span class="line">        <span class="keyword">return</span> socket.on(<span class="string">"close"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code, message</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">console</span>.log((<span class="string">""</span> + <span class="keyword">this</span>.name + <span class="string">": Disconnected WebSocket ("</span>) + self.wsServer.clients.length + <span class="string">" total)"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">module</span>.exports = VideoStream;</span><br><span class="line"></span><br><span class="line">&#125;).call(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p><p>node-rtsp-stream/videoStream.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Mpeg1Muxer, child_process, events, util;</span><br><span class="line"></span><br><span class="line">    child_process = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"></span><br><span class="line">    util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"></span><br><span class="line">    events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line">    Mpeg1Muxer = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> self;</span><br><span class="line">        self = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.url = options.url;</span><br><span class="line">        <span class="keyword">this</span>.stream = child_process.spawn(<span class="string">"ffmpeg"</span>, </span><br><span class="line">            [</span><br><span class="line">                <span class="string">"-rtsp_transport"</span>,</span><br><span class="line">                <span class="string">"tcp"</span>,</span><br><span class="line">                <span class="string">"-i"</span>,</span><br><span class="line">                <span class="keyword">this</span>.url,</span><br><span class="line">                <span class="string">'-s'</span>, </span><br><span class="line">                <span class="comment">// 图像宽高</span></span><br><span class="line">                <span class="string">`<span class="subst">$&#123;options.width&#125;</span>x<span class="subst">$&#123;options.height&#125;</span>`</span>, </span><br><span class="line">                <span class="string">'-f'</span>, </span><br><span class="line">                <span class="string">'mpeg1video'</span>, </span><br><span class="line">                <span class="string">'-b:v'</span>, </span><br><span class="line">                <span class="string">'800k'</span>, </span><br><span class="line">                <span class="string">'-r'</span>, </span><br><span class="line">                <span class="string">'30'</span>, </span><br><span class="line">                <span class="string">'-'</span></span><br><span class="line">            ], </span><br><span class="line">            &#123;</span><br><span class="line">                detached: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">this</span>.inputStreamStarted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.stream.stdout.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.emit(<span class="string">'mpeg1data'</span>, data);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.stream.stderr.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.emit(<span class="string">'ffmpegError'</span>, data);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// kill ffmpeg</span></span><br><span class="line">        <span class="keyword">this</span>.stream.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// console.log(self.stream.pid)</span></span><br><span class="line">            self.stream.stdin.pause();</span><br><span class="line">            self.stream.kill()</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'ffmpeg is be kill'</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听 ffmpeg 退出</span></span><br><span class="line">        <span class="keyword">this</span>.stream.on(<span class="string">'exit'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> self.emit(<span class="string">'ffmpegClose'</span>, code)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    util.inherits(Mpeg1Muxer, events.EventEmitter);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">module</span>.exports = Mpeg1Muxer;</span><br><span class="line"></span><br><span class="line">&#125;).call(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure></p><ol start="2"><li>node 端使用</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)()</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).Server(app)</span><br><span class="line"><span class="keyword">const</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>)(server)</span><br><span class="line"><span class="comment">// 引入改造后的 node-rtsp-stream</span></span><br><span class="line"><span class="keyword">const</span> Rtsp = <span class="built_in">require</span>(<span class="string">'./node-rtsp-stream'</span>)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8081</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server listening on 8081'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// uri 以海康摄像机的 rtsp 协议为例</span></span><br><span class="line"><span class="keyword">let</span> uri = <span class="string">'rtps://admin:password@ip:port/h264/ch1/sub/av_stream'</span></span><br><span class="line"><span class="keyword">let</span> stream = <span class="keyword">new</span> Rtsp(&#123;</span><br><span class="line">    name: <span class="string">'rtsp_stream'</span>,</span><br><span class="line">    streamUrl: uri,</span><br><span class="line">    wsPort: <span class="number">11111</span>,</span><br><span class="line">    width: <span class="number">720</span>,</span><br><span class="line">    height: <span class="number">405</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'start'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stream'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">stream.on(<span class="string">'stop'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stream stopped'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> pipeStream = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        socket.emit(<span class="string">'data'</span>, data)</span><br><span class="line">    &#125;</span><br><span class="line">    stream.on(<span class="string">'data'</span>, pipeStream)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换摄像机</span></span><br><span class="line">    socket.on(<span class="string">'URI'</span>, data =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data)</span><br><span class="line">        uri = <span class="string">`rtsp://<span class="subst">$&#123;data.userName&#125;</span>:<span class="subst">$&#123;data.passWord&#125;</span>@<span class="subst">$&#123;data.ip&#125;</span>:<span class="subst">$&#123;data.port&#125;</span>/h264/ch1/sub/av_stream`</span></span><br><span class="line">        stream.streamUrl = uri;</span><br><span class="line">        <span class="comment">// 重启</span></span><br><span class="line">        stream.restart()</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'disconnect'</span> () =&gt; &#123;</span><br><span class="line">        stream.removeListener(<span class="string">'data'</span>, pipeStream)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="3"><li>客户端</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">'can'</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'jsmpeg.min.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> canvas = <span class="built_in">document</span>.querySelector(<span class="string">'#can'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ws = <span class="keyword">new</span> WebSocket(<span class="string">'ws://127.0.0.1:11111'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> player = <span class="keyword">new</span> jsmpeg(ws, &#123;</span></span><br><span class="line"><span class="undefined">        canvas: canvas,</span></span><br><span class="line"><span class="javascript">        autoplay: <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个方案其实使用了很久一直都没发现问题, 也没有出现过花屏延迟累计的情况. 但是在一路摄像机安置在天桥附近人流量剧增, 与这个视频预览同一页面还有一个人脸实时抓拍的即时消息推送的功能, 导致在20 - 30分钟浏览器直接假死或者崩溃.(然后这个方案又凉了😂)</p><h3 id="方案三-FFmpeg-Nginx-video-js"><a href="#方案三-FFmpeg-Nginx-video-js" class="headerlink" title="方案三: FFmpeg + Nginx + video.js"></a>方案三: FFmpeg + Nginx + video.js</h3><p>在经过两次实验 + 失败之后找到一个较为大众的解决方式, 前两种方案都是通过库直接使用 rtsp 转成 bytes 提供给外部使用, 而方案三的流程如下:</p><ul><li>Node 使用 <a href="https://github.com/fluent-ffmpeg/node-fluent-ffmpeg" target="_blank" rel="noopener">fluent-ffmpeg</a> 调整参数启动 FFmpeg</li><li>FFmpeg 负责编码再解码后转为 RTMP 协议</li><li>Node 将流推到 Nginx (nginx 需要安装 <a href="https://github.com/arut/nginx-rtmp-module#example-nginxconf" target="_blank" rel="noopener">nginx-rtmp-modules</a> 插件)</li><li>客户端使用 Video.js 访问 Nginx 配置的连接并播放视频</li></ul><p>在这个阶段又遇到了不同厂商的摄像机, 在同一协议下不能正常运作, 在此也记录一下各厂商的 rtsp 协议</p><ul><li>海康威视: rtps://admin:password@ip:port/h264/ch1/sub/av_stream</li><li>大华: rtps://admin:password@ip:port/cam/realmonitor?channel=1&amp;subtype=0</li><li>天地伟业: rtps://admin:password@ip:port/1/1</li><li>科达: rtps://admin:password@ip:port/id=1</li><li>华易明新: rtps://admin:password@ip:port/ch3</li></ul><p><strong>示例:</strong></p><p>node 端<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uri = <span class="string">'rtps://admin:password@ip:port/h264/ch1/sub/av_stream'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FFMpeg 命令参数设置</span></span><br><span class="line"><span class="comment">// ffmpeg - i rtsp://admin:hk123456@192.168.0.64:554/h264/ch1/sub/av_stream -fflags nobuffer -vcodec libx264 </span></span><br><span class="line"><span class="comment">// -preset superfast -f flv -r 15 -s 1280x720 -an rtmp://127.0.0.1:1935/live/camera</span></span><br><span class="line"><span class="keyword">let</span> ffmpeg = <span class="built_in">require</span>(<span class="string">'fluent-ffmpeg'</span>)</span><br><span class="line"><span class="keyword">let</span> running = <span class="literal">false</span></span><br><span class="line"><span class="keyword">var</span> command = ffmpeg(uri)</span><br><span class="line">    .outputOptions([</span><br><span class="line">        <span class="string">'-fflags'</span>,</span><br><span class="line">        <span class="string">'nobuffer'</span>,</span><br><span class="line">        <span class="string">'-vcodec'</span>,</span><br><span class="line">        <span class="string">'libx264'</span>,</span><br><span class="line">        <span class="string">'-preset'</span>,</span><br><span class="line">        <span class="string">'superfast'</span>,</span><br><span class="line">        <span class="comment">// '-rtsp_transport',</span></span><br><span class="line">        <span class="comment">// 'tcp',</span></span><br><span class="line">        <span class="comment">// '-threads',</span></span><br><span class="line">        <span class="comment">// '4',</span></span><br><span class="line">        <span class="string">'-f'</span>,</span><br><span class="line">        <span class="string">'flv'</span>,</span><br><span class="line">        <span class="string">'-r'</span>,</span><br><span class="line">        <span class="string">'15'</span>,</span><br><span class="line">        <span class="string">'-s'</span>,</span><br><span class="line">        <span class="string">'1280x720'</span>,</span><br><span class="line">        <span class="string">'-an'</span></span><br><span class="line">    ])</span><br><span class="line">    <span class="comment">// 此处的 /live/camera, camera类似于一个房间的概念, 你可以设置为你想要的名字</span></span><br><span class="line">    .save(<span class="string">`rtmp://<span class="subst">$&#123; nginxHost &#125;</span>:<span class="subst">$&#123; nginxPort &#125;</span>/live/camera`</span>)</span><br><span class="line">    .on(<span class="string">'start'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        running = <span class="literal">true</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'stream is start: '</span> + e)</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        running = <span class="literal">false</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ffmpeg is end'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        running = <span class="literal">false</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'ffmpeg is error! '</span>+ err)</span><br><span class="line">        reloadStream(uri)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reloadStream = <span class="function">(<span class="params">uri, userAgents</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!uri) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">let</span> userAgent = userAgents</span><br><span class="line">    <span class="keyword">if</span> (running) &#123;</span><br><span class="line">        command.kill()</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (command._inputs[<span class="number">0</span>]) &#123;</span><br><span class="line">            command._inputs[<span class="number">0</span>].source = uri</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            command.input(uri)</span><br><span class="line">        &#125;</span><br><span class="line">        command.run()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> camFactory = &#123;</span><br><span class="line">    <span class="comment">// 海康</span></span><br><span class="line">    <span class="string">'0'</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'h264/ch1/sub/av_stream'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 大华</span></span><br><span class="line">    <span class="string">'1'</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'cam/realmonitor?channel=1&amp;subtype=0'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 天地伟业</span></span><br><span class="line">    <span class="string">'2'</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'1/1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 科达</span></span><br><span class="line">    <span class="string">'3'</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'id=1'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 华易明新</span></span><br><span class="line">    <span class="string">'4'</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'ch3'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'connection'</span>)</span><br><span class="line">    <span class="keyword">let</span> cameraInfo = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (cameraInfo.cameraName) &#123;</span><br><span class="line">        socket.emit(<span class="string">'CameraInfo'</span>, cameraInfo)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取网络摄像头信息</span></span><br><span class="line">    socket.on(<span class="string">'URI'</span>, data =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (cameraInfo.cameraName === data.cameraName || cameraInfo.ip === data.ip) <span class="keyword">return</span></span><br><span class="line">        cameraInfo = data</span><br><span class="line">        cameraInfo.factory = data.factory || <span class="string">'0'</span></span><br><span class="line">        uri = <span class="string">`rtsp://<span class="subst">$&#123;data.userName&#125;</span>:<span class="subst">$&#123;data.passWord&#125;</span>@<span class="subst">$&#123;data.ip&#125;</span>:<span class="subst">$&#123;data.RTSP&#125;</span>/<span class="subst">$&#123;camFactory[cameraInfo.factory]()&#125;</span>`</span></span><br><span class="line">        reloadStream(uri, data.userAgent)</span><br><span class="line">        socket.emit(<span class="string">'CameraInfo'</span>, cameraInfo)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'disconnect'</span>, _ =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'disconnect'</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">    socket.on(<span class="string">'end'</span>, _ =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'socket-io end'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    socket.on(<span class="string">'err'</span>, err =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>FFmpeg 的参数对视频推流的画面质量和延迟有较大影响, 以下对我用过的 FFmpeg 参数作一些说明.如果使用海康摄像机 rtsp 转 rtmp 是可以直接使用 <code>copy</code> 参数性能会提高很多, 剩去了 FFmpeg 编码解码的过程. 下面的例子是当时的项目要兼容的华易明新的摄像机, 所以没有使用 <code>copy</code> 参数</p><p><strong>延迟影响相关参数(以下测试都在海康威视和华易明新摄像机测试):</strong></p><ol><li><p>fast 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtsp://admin:hk123456@192.168.0.64:554/h264/ch1/sub/av_stream -vcodec libx264</span><br><span class="line"> -preset fast -f flv -r 15 -s 1280x720 -an rtmp://127.0.0.1:1935/live/camera</span><br></pre></td></tr></table></figure><p> fast 参数延迟表现较为不明显</p></li><li><p>superfast 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtsp://admin:hk123456@192.168.0.64:554/h264/ch1/sub/av_stream -vcodec libx264</span><br><span class="line"> -preset  superfast -f flv -r 15 -s 1280x720 -an rtmp://127.0.0.1:1935/live/camera</span><br></pre></td></tr></table></figure><p> superfast 参数表现为 2-3 秒延迟, 但是画质会下降一点</p></li><li><p>ultrafast 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtsp://admin:hk123456@192.168.0.64:554/h264/ch1/sub/av_stream -vcodec libx264</span><br><span class="line"> -preset  ultrafast -f flv -r 15 -s 1280x720 -an rtmp://127.0.0.1:1935/live/camera</span><br></pre></td></tr></table></figure><p> ultrafast 参数在我实验中表现跟 superfast 的延迟差距不是特别大, 大概在 1-2 秒左右, 画质会下降的比较明显</p></li><li><p>zerolatency 和 ultrafast 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtsp://admin:hk123456@192.168.0.64:554/h264/ch1/sub/av_stream -tune zerolatency </span><br><span class="line">-vcodec libx264 -preset  ultrafast -f flv -r 15 -s 1280x720 -an rtmp://127.0.0.1:1935/live/camera</span><br></pre></td></tr></table></figure><p> 讲道理第一个参数是零延迟, 但是添加这个参数之后在天桥部署的摄像机花屏会非常严重</p></li><li><p>nobuffer 和 superfast 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i rtsp://admin:hk123456@192.168.0.64:554/h264/ch1/sub/av_stream -fflags nobuffer</span><br><span class="line"> -vcodec libx264 -preset  superfast -f flv -r 15 -s 1280x720 -an rtmp://127.0.0.1:1935/live/camera</span><br></pre></td></tr></table></figure><p> nobuffer 参数表示不使用缓存, 在以上实验中华易明新摄像机在解码中丢包非常严重, nobuffer 参数在解码跟不上发送时放弃缓存, 所以最终选用 nobuffer + superfast 参数达到一个平衡的状态. </p></li></ol><p><strong>其他参数</strong></p><ul><li><p>rtsp_transport 参数: 传输方式, tcp/udp 两种, 默认为 udp.</p><p>  本来 udp 的传输方式更快消耗的资源也更少, 但是项目中反而改成 tcp 的方式效果更好</p></li><li><p>threads 参数</p><p>  threads 也是讲道理应该是解码线程数多一点效果好, 反而项目中将线程数减少效果更佳</p></li></ul><p>以上两个参数是我没理解的部分, 当然也可能是当时项目的环境有所影响. 这个项目也有一点奇怪的地方在这儿一起说, 在启动 FFmpeg 转码时电脑会蓝屏. 最终排查到的问题是: 1. CPU 启用涡轮加速 2. flash 开启硬件加速 3. ffmpeg 版本 4. 华易明新摄像机</p><p>解决方法: </p><ol><li>CPU 涡轮加速关闭</li><li>flash 关闭硬件加速 (据说是 flash 本身实现硬件加速不好) </li><li>将 FFmpeg 版本换至最新</li><li>更新摄像机硬件包</li></ol><p>蓝屏的这个问题只在一台电脑上遇见过特殊性比较高, 仅供参考.</p><p>nginx 配置<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">rtmp &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        # 服务端口(默认端口)</span><br><span class="line">        listen 1935;</span><br><span class="line">        # 直播</span><br><span class="line">        application live &#123;</span><br><span class="line">            live on;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- Old version compatible with flash --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;link href="//vjs.zencdn.net/5.19/video-js.min.css" rel="stylesheet"&gt;</span></span><br><span class="line"><span class="comment">  &lt;script src="//vjs.zencdn.net/5.19/video.min.js"&gt;&lt;/script&gt;   --&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- New version uncompatible with flash --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"http://vjs.zencdn.net/6.2.4/video-js.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://vjs.zencdn.net/6.2.4/video.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./videojs-flash.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"> videojs.options.flash.swf = <span class="string">'./video-js.swf'</span>; </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"my-player"</span> <span class="attr">class</span>=<span class="string">"video-js"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"rtmp://127.0.0.1:1935/live/camera"</span> <span class="attr">type</span>=<span class="string">"rtmp/mp4"</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  videojs(<span class="string">'my-player'</span>, &#123;</span></span><br><span class="line"><span class="javascript">    controls: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">    autoplay: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">    flash: &#123;</span></span><br><span class="line"><span class="javascript">      swf: <span class="string">'./video-js.swf'</span></span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="undefined">    height: 300,</span></span><br><span class="line"><span class="undefined">    width: 300</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>补充一句在 vue 中使用可以试试 <a href="https://github.com/surmon-china/vue-video-player" target="_blank" rel="noopener">vue-video-player</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这一波网络摄像机的直播还是涨了很多姿势, 达成 FFmpeg 调参员. 不过在我离职之前还有一个问题一直没有解决, 客户端在运行 3-4 小时之后就会黑屏, 在刷新页面后又恢复. 我尝试过改 chrome 中 flash 的设置还是不行, 苟且了一点定时刷新暂时解决. 最终还是 flash 这个问题没法从根本上解决.</p><p>Created on 2017/7/26 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于网络摄像机做视频预览这块, 本身其实是非常陌生的, 当时接到这个需求也是相当的头疼(对于当时一年经验不到的我来说).当时我们的应用场景是: 多路网络摄像机通过局域网连接, PC 端能够实时预览监控画面并且画质达到720p, 延迟不能超过10秒, 多个摄像机能够切换查看.
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://yoursite.com/tags/Node-js/"/>
    
      <category term="FFmpeg" scheme="https://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Babel生态</title>
    <link href="https://yoursite.com/2018/04/09/Babel/"/>
    <id>https://yoursite.com/2018/04/09/Babel/</id>
    <published>2018-04-09T09:55:20.000Z</published>
    <updated>2018-05-13T03:49:29.853Z</updated>
    
    <content type="html"><![CDATA[<p>对于 babel 的使用, 一直停留在与 webpack 结合使用, 以及在 Vue 开发环境下脚手架又是开箱即用. 导致很多 babel 的包, 我都不清楚他们是干什么的. 比如 babel-register/ babel-runtime/ helpers/ 各种 presets 以及 transform-runtime 和 babel-polyfill 的区别, 所以总结一下.</p><h3 id="babel-cli"><a href="#babel-cli" class="headerlink" title="babel-cli"></a>babel-cli</h3><p>我理解为 babel 的 command 全家桶, 用于在命令行操作的. 里面包含了 <code>babel</code>/ <code>babel-external-helpers</code>/ <code>babel-node</code> 3个命令</p><ul><li>babel: 用于编译代码</li><li>babel-external-helpers: 用于生成一些 halper 函数, 包含 babel 所有的 hepler 函数 (如: toArray 函数, jsx 转化函数). 这些函数实在 babel transform 的时候用, 都放在 <code>babel-helpers</code> 这个包中, 当这些 helpers 被用到就会被放置在生成代码的顶部. 但是当多个文件都用到了 helpers 函数就会产生冗余代码, 所以 babel 提供这个命令生成一个包含所有 helpers 的 js 文件用于直接引用.(然后可以通过 plugin 去检查全局时候存在这个模块, 存在就不定义)</li><li>babel-node: 主要是实现在 node 中写代码和执行脚本的能力, 可以直接运行 ES6代码. 比如直接在 node 中写 jsx, 通过这个就可以执行. 但是要把它编译成可执行的脚本还需要 <code>babel-register</code></li></ul><p>安装<br><code>npm install --global babel-cli</code></p><p>用法<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">babel example.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 转码结果写入文件</span><br><span class="line">babel example.js -o result.js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 整个目录转码</span><br><span class="line">babel src -d lib</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 生成 source map 文件</span><br><span class="line">babel src -d lib -s</span><br></pre></td></tr></table></figure></p><p>全局环境下 babel 无法支持不同版本的 babel, 所以安全的做法还是把 babel 装在项目中<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-cli</span><br></pre></td></tr></table></figure></p><p>package.json 改成:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"script"</span>: <span class="string">"babel src -d lib"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>babel-register</strong><br>它的特点就是实时编译, 不会输出文件, 用来改写 <code>require</code> 命令为它加上钩子. <code>require</code> 进来的文件就会被转码, 但是它不会转码当前文件中的代码.</p><p>安装<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-register</span><br></pre></td></tr></table></figure></p><p>使用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须先加载 register</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'babel-register'</span>)</span><br><span class="line"><span class="comment">// 然后 register 就会对 test.js 文件转码</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'test.js'</span>)</span><br></pre></td></tr></table></figure></p><blockquote><p>由于 <code>babel-register</code> 是即时转码, 所以只适用于开发环境使用.</p></blockquote><h3 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a>babel-core</h3><p><code>babel-core</code> 可以说是 babel 最为核心的一个包, 可以把它看成一个编译器, babel 核心的 API 都在里面. 比如: transform 处理转码, 因为 ES6 的语法跟老语法不同, 所以先将我们的代码转换为 AST(抽象语法树), 然后分别做处理转化为 ES5. webpack 的 babel-loader 就是调用这些 API 完成转译的. <a href="https://babeljs.cn/docs/usage/api/" target="_blank" rel="noopener">这里是详细的 API</a></p><blockquote><p>这里需要注意的是: <code>babel-core</code> 仅关注 code transform, 也就是说它只做语法上的转换, 比如箭头函数. 所以并不是什么都能用 babel 来转换的, 如果涉及到新的 API 就需要你用 polyfill 来转译, 比如 <code>Promise</code>.</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整块引入</span></span><br><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>)</span><br><span class="line"><span class="comment">// 也可以选择某个 API 单独使用</span></span><br><span class="line"><span class="keyword">import</span> &#123; transform &#125; <span class="keyword">from</span> <span class="string">'babel-core'</span></span><br></pre></td></tr></table></figure><p>主要的 API:</p><p><strong>babel.transform(code: string, options?: Object)</strong><br>将传入的 code 做转换, 返回值为一个对象, 参数为: 生成的对象, source map 和 AST</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = babel.transform(<span class="string">"code();"</span>, options);</span><br><span class="line">result.code</span><br><span class="line">result.map</span><br><span class="line">result.ast</span><br></pre></td></tr></table></figure><p><strong>babel.transformFile(filename: string, options?: Object, callback: Function)</strong><br>异步转译文件中的所有内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">babel.transformFile(<span class="string">'filename.js'</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  result <span class="comment">// &#123; code, map, ast &#125;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>babel.transformFileSync(filename: string, options?: Object)</strong><br><code>babel.transformFile</code> 的同步版本, 返回值为 <code>filename</code> 文件中转译后的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel.transformFileSync(filename, options) <span class="comment">// &#123; code, map, ast &#125;</span></span><br></pre></td></tr></table></figure><p><strong>babel.transformFromAst(ast: Object, code?: string, options?: Object)</strong><br>反转译, 给一个 AST 转为 code</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> code = <span class="string">'if (true) return'</span></span><br><span class="line"><span class="keyword">const</span> ast = babylon.parse(code, &#123; <span class="attr">allowReturnOutsideFunction</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> &#123; code, map, ast &#125; = babel.transformFormAst(ast, code, options)</span><br></pre></td></tr></table></figure><h3 id="babel-runtime"><a href="#babel-runtime" class="headerlink" title="babel-runtime"></a>babel-runtime</h3><p><a href="https://babeljs.cn/docs/plugins/transform-runtime/" target="_blank" rel="noopener"><code>babel-runtime</code></a> 这个包其实就是把 core-js 和 regenerator 组合起来供使用, 它和 <code>babel-polyfill</code> 的都是为了模拟 ES6 环境. 之前提到的 <code>babel-core</code> 只对语法进行转换, 但不支持 Promise, Set, Map, array.reduce, Array.form, genertor, async 这些新 API 的编译, 所以才会用到这两个东西.</p><p><strong>core-js</strong>: 主要实现了 Promise, Symbols, ES7提案等等的 polyfill, 包含了大部分的 JavaScript 最新标准的垫片.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要单个引用后再使用</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'core-js/array/reduce'</span>)</span><br></pre></td></tr></table></figure></p><p><strong>regenerator</strong>: 主要实现 generator/yeild, async/await (不知道为啥 core-js 不把这两个一起实现了…)</p><p><strong>helpers</strong>: <code>babel-runtime</code> 里也有 helpers, 它里面的 helpers 相当于之前提到的 <code>babel-external-helpers</code> 生成的 helpers.js, 只不过把每个 helpers 函数都单独放到一个文件夹里而已. 这样配合 transform 的时候, 需要用到 helpers 函数就可以直接从 <code>babel-runtime</code> 中引用了.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> _asyncToGenerator2 = <span class="built_in">require</span>(<span class="string">'babel-runtime/helpers/asyncToGenerator'</span>)</span><br></pre></td></tr></table></figure></p><p>区别: </p><ul><li><a href="https://babeljs.cn/docs/usage/polyfill" target="_blank" rel="noopener">babel-polyfill</a>: 是通过全局对象和内置对象的 prototype 上添加方法来达到目的, 所以一旦引入 <code>babel-polyfill</code> 就会污染全局环境.</li><li>babel-runtime: <code>babel-runtime</code> 是一个模块, 所以它不会污染全局环境和内置对象的原型. 它的做法引入需要的 helper 函数(类似: <code>const Promise = require(&#39;babel-runtime/core-js/promise&#39;)</code> 来引入 Promise).</li></ul><p>优缺点:</p><ul><li>babel-poly-fill: 引入一劳永逸, 但是污染环境.</li><li>babel-runtime: <ol><li>手动引入不方便</li><li>直接在代码中引入 helper 函数意味着不能共享, 最终打包出来会有很多冗余代码(引入的都是全量的 polyfill). </li></ol></li></ul><p>所以要配合 <code>babel-plugin-transform-runtime</code> (很多地方都是把 <code>babel-runtime</code> 和 <code>babel-plugin-transform-runtime</code> 统称为 transform-runtime, 因为它俩得合在一起才好用) 来达到按需引入 helper 避免重复打包和手动引入的痛苦, 它主要是做一层映射: 将 <code>babel-runtime</code> 内引用到的 core-js 或 regenerator.js 映射到具体对应的 helper. </p><blockquote><p>注意: <code>babel-runtime</code> 无法转码实例方法, 即内置对象原型上的方法, 只能通过 <code>babel-polyfill</code> 来转码. 比如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.find()</span><br><span class="line"><span class="string">'hello'</span>.includes(<span class="string">'h'</span>)</span><br></pre></td></tr></table></figure></p></blockquote><p>另外, 关于为什么 <code>babel-runtime</code> 是 dependencies 依赖, 因为他只是集合了 polyfill 的一个 library, 对应需要的 polyfill 都是要引入项目中, 并跟项目代码一起打包的.</p><h3 id="babel-preset-env"><a href="#babel-preset-env" class="headerlink" title="babel-preset-env"></a>babel-preset-env</h3><p>它能根据当前的运行环境, 自动确定你需要的 plugins 和 polyfills, babel 的配置官方推荐是写到 <code>.babelrc</code> 文件中, 以 <code>Vue-cli</code> 的 babel 配置为例.<a href="https://babeljs.cn/docs/plugins/preset-env/" target="_blank" rel="noopener">详细参数设置及说明</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [<span class="string">"env"</span>, </span><br><span class="line">      &#123; </span><br><span class="line">        "modules": false // 设置 ES6 模块转译的模式, 默认是 commonjs</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    // 需要支持到哪个阶段的 JavaScript 版本</span><br><span class="line">    <span class="string">"stage-2"</span></span><br><span class="line">  ],</span><br><span class="line">  // 需要的插件</span><br><span class="line">  "plugins": [</span><br><span class="line">    "transform-runtime", // 虽然这里没有写 babel-runtime, 但是 transform-runtime 依赖于它, 所以还是要安装</span><br><span class="line">    <span class="string">"transform-vue-jsx"</span></span><br><span class="line">  ],</span><br><span class="line">  // 编译过程是否保留注释</span><br><span class="line">  "comments": false,</span><br><span class="line">  "env": &#123;</span><br><span class="line">    "test": &#123;</span><br><span class="line">      "presets": ["env", "stage-2"],</span><br><span class="line">      "plugins": [ "istanbul"]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来 <code>babel-preset-env</code> 中有一个 useBuiltIns 选项(默认值是 false), 就是它实现的根据运行环境并判断需要什么 polyfill, 达到按需引入而不是整个引入, 对于 <code>import &#39;babel-polyfill&#39;</code> 就很棒了. 但是可以看到 vue-template 并没有使用这个选项, 这是因为   <a href="javascript:" title="我消不掉这个超链接😑" target="_blank" rel="noopener">babel-preset-env@1.x</a> 的版本没有办法很好消除未使用的 polyfill, 在2.x 版本下可以用 <code>usebuiltIns: &#39;usage&#39;</code>达到目的.</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>babel 还有很多相关的东西没说到, 只挑了几个最重要的来说, 具体的 helpers/ plugins 都可以到<a href="https://github.com/babel/babel/tree/master/packages" target="_blank" rel="noopener">官方仓库</a>查看</p><ul><li><a href="https://github.com/babel/babel/tree/master/packages/babylon" target="_blank" rel="noopener">badylon</a>: 词法解析器</li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-traverse" target="_blank" rel="noopener">babel-traverse</a>: 用于遍历, 维护整个 AST 的状态</li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-generator" target="_blank" rel="noopener">babel-generator</a>: 根据 AST 生成代码</li></ul><h4 id="babel-的工作流程"><a href="#babel-的工作流程" class="headerlink" title="babel 的工作流程"></a>babel 的工作流程</h4><p>输入需要转码的代码 -&gt; badylon 解析 -&gt; 得到 AST -&gt;<br>babel-traverse 遍历转译 -&gt; 得到新的 AST -&gt;<br>最后 babel-generator 根据新的 AST 生成代码</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>整个来说我觉得还是 <code>babel-runtime</code> 和 <code>babel-polyfill</code> 比较难区分, 其实两者的核心都在于 <a href="https://github.com/zloirock/core-js#basic" target="_blank" rel="noopener">core-js</a> 只是各有优缺点而已, 下面会再简要总结一下区别. 其他的话只需要知道每个东西是干啥的就行了.</p><ul><li>babel-polyfill: 污染环境, 支持实例方法(如果只想引入一些特定的polyfill, 那就去 <a href="https://github.com/zloirock/core-js#basic" target="_blank" rel="noopener">core-js</a> 中找相应的方法自己手动 require 进来); </li><li>runtime: 按需引用,不支持实例方法.</li></ul><p>Created on 2018-4-11 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于 babel 的使用, 一直停留在与 webpack 结合使用, 以及在 Vue 开发环境下脚手架又是开箱即用. 导致很多 babel 的包, 我都不清楚他们是干什么的. 比如 babel-register/ babel-runtime/ helpers/ 各种 pre
      
    
    </summary>
    
    
      <category term="Babel" scheme="https://yoursite.com/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>跨域</title>
    <link href="https://yoursite.com/2018/04/02/%E8%B7%A8%E5%9F%9F/"/>
    <id>https://yoursite.com/2018/04/02/跨域/</id>
    <published>2018-04-02T09:01:24.000Z</published>
    <updated>2018-05-13T03:49:29.860Z</updated>
    
    <content type="html"><![CDATA[<p>跨域这块是前后端分离必经的一条路, 这次好好整理一下关于跨域方面知识.</p><h3 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域?"></a>什么是跨域?</h3><p>跨域是受同源策略的影响而导致的, 指一个源下的资源试图操作另一个源下的资源.</p><blockquote><p>那么, 什么又是同源策略呢?<br>就是限制从一个源的资源如何与另一个源的资源交互, 用于隔离潜在的恶意文件, 保证文件的安全性. 所谓的同源是指: 协议/域名/端口 三者相同, 即使两个不同的域名指向同一个 IP 地址, 也非同源. 如果没有同源策略, 浏览器很容易受到 XSS/CSRF 等的攻击(XSS: 跨站脚本攻击;CSRF: 跨站请求伪造).</p></blockquote><p>同源策略将限制以下行为:</p><ul><li>Cookie/LocalStorage/IndexDB</li><li>DOM 无法获得</li><li>Ajax 请求无法发送</li></ul><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><h4 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1. JSONP"></a>1. JSONP</h4><p>它的特性是简单/ 兼容性好/ 改造小, 但是不支持 POST 请求. 原理是通过 <code>script</code> 标签放入回调函数, 服务端将返回数据塞入回调函数即可.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createScript = <span class="function"><span class="params">url</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span></span><br><span class="line">    script.src = url</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入请求地址</span></span><br><span class="line">createScript(<span class="string">'http://www.example.com/api?callback=foo'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 服务端返回数据</span></span><br><span class="line">    <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-document-domain"><a href="#2-document-domain" class="headerlink" title="2. document.domain"></a>2. document.domain</h4><p>通过设置域名来访问 <code>Cookie</code> 和 操作 <code>iframe</code> 窗口, 此方案只适用于主域相同, 子域不同的场景.</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 父窗口 (http://www.main.com/a.html)</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">'iframe'</span> <span class="attr">src</span>=<span class="string">'http://www.child.main.com/b.html'</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'main.com'</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.cookie = <span class="string">'test=hi'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> user = <span class="string">'admin'</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 子窗口 (http://www.child.main.com/b.html)</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.domain = <span class="string">'example.com'</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> parentMessage = <span class="built_in">document</span>.cookie</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">window</span>.parent.user)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-window-location-hash"><a href="#3-window-location-hash" class="headerlink" title="3. window.location.hash"></a>3. window.location.hash</h4><p>通过修改 hash 值来传递参数, 修改 hash 值并不会刷新页面但字节数有限制.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口向子窗口写入 hash</span></span><br><span class="line"><span class="keyword">let</span> src = <span class="string">`<span class="subst">$&#123;childUrl&#125;</span>#test=hi`</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#iframe'</span>).src = src</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子窗口</span></span><br><span class="line"><span class="comment">// 接收消息</span></span><br><span class="line"><span class="built_in">window</span>.onhashchange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> meg = <span class="built_in">window</span>.location.hash</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子窗口向父窗口写入 hash</span></span><br><span class="line"><span class="built_in">window</span>.parent.href = <span class="string">`<span class="subst">$&#123;<span class="built_in">window</span>.parent.href&#125;</span>#world`</span></span><br></pre></td></tr></table></figure><h4 id="4-window-name"><a href="#4-window-name" class="headerlink" title="4. window.name"></a>4. window.name</h4><p>window.name 只要在同一个窗口, 无论是否同源前一个页面设置了这个属性, 后一个页面就能读取. 它可以支持2M 大小的值但是变化需要自己监听.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父窗口 (http://www.main.com/a.html)</span></span><br><span class="line"><span class="keyword">const</span> proxy = <span class="function">(<span class="params">url, callback</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line">    <span class="keyword">let</span> state = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转到跨域页面</span></span><br><span class="line">    iframe.src = url</span><br><span class="line"></span><br><span class="line">    iframe.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 第二次代理也加载成功之后, 读取 name 属性</span></span><br><span class="line">            callback(<span class="built_in">window</span>.name)</span><br><span class="line">            <span class="built_in">document</span>.body.removeChild(iframe);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state === <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//  第一次跳转到代理页面</span></span><br><span class="line">            iframe.src = <span class="string">'http://www.main.com/proxy.html'</span></span><br><span class="line">            state = <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(iframe)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入跨域页面 URL</span></span><br><span class="line">proxy(<span class="string">'http://www.child.com/b.html'</span>, (name) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name) <span class="comment">// 'This message from b.html'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跨域子窗口 (http://www.child.com/b.html) </span></span><br><span class="line"><span class="comment">// 设置 name 属性</span></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">'This message from b.html'</span></span><br></pre></td></tr></table></figure><h4 id="5-postMessage"><a href="#5-postMessage" class="headerlink" title="5. postMessage"></a>5. postMessage</h4><p>postMessage(跨文档通信) 是 HTML5 中为了解决跨域出的 API, 可以解决以下几种问题:</p><ol><li>页面和其打开的新窗口的数据传递</li><li>多窗口之间消息传递</li><li>页面与嵌套的iframe消息传递</li><li>上面三个场景的跨域数据传递</li></ol><p>发送消息通过 <code>postMessage(data, origin)</code> 方法, 该方法接收两个参数: </p><ul><li>data: 需要传递的参数, 由于部分浏览器只支持字符串, 所以传递之前最好先 <code>JSON.stringify()</code> 序列化</li><li>origin: 是接收方的 协议 + 主机 + 端口, 可以是设置为 <code>*</code>, 指定与当前窗口同源的话设置为 <code>/</code>.</li></ul><p>接收消息通过 <code>message</code> 事件监听, 该事件有一个 <code>event</code> 参数提供三个属性:</p><ul><li>event.origin: 消息接收方</li><li>event.source: 消息来源</li><li>event.data: 消息体</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 父窗口 (http://www.main.com/a.html)</span><br><span class="line"><span class="tag">&lt;<span class="name">firame</span> <span class="attr">id</span>=<span class="string">'iframe'</span> <span class="attr">src</span>=<span class="string">'http://www.child.com/b.html'</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> iframe = <span class="built_in">document</span>.querySelector(<span class="string">'#iframe'</span>)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> url = iframe.src</span></span><br><span class="line"><span class="javascript">    iframe.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> data = &#123;</span></span><br><span class="line"><span class="javascript">            name: <span class="string">'parent'</span>,</span></span><br><span class="line"><span class="javascript">            message: <span class="string">'This message from parent'</span></span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 跨域向子窗口发送消息</span></span></span><br><span class="line"><span class="javascript">        iframe.contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(data), url)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 父窗口监听子窗口发送的消息</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 过滤不属于自己的消息</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (data.origin !== <span class="string">'http://www.main.com/a.html'</span>) <span class="keyword">return</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'data from child: '</span> + event.data)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 子窗口 (http://www.child.com/b.html)</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onmessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'data from main: '</span> + event.data)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(event.data)</span></span><br><span class="line"><span class="javascript">        data.name = <span class="string">'child'</span></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="comment">// 收到消息后处理再发送给父窗口</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(data), <span class="string">'http://www.main.com/a.html'</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="5-CORS"><a href="#5-CORS" class="headerlink" title="5. CORS"></a>5. CORS</h4><p>跨域资源共享(Cross-origin-resource-sharing), 它允许浏览器向跨源服务器发出 <code>XMLHttpRequest</code> 请求. CORS 现在也是主流的跨域解决方案, 这种方式只需要后端做处理, 如果要带上 cookie 那么前后端都要设置.</p><p>带 cookie 传输:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>请求实例:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> XMLRequest = <span class="function">(<span class="params">method = <span class="string">'GET'</span>, url = <span class="string">''</span>, data = <span class="literal">null</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> xhr = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        xhr = <span class="keyword">new</span> ActiveXObject(<span class="string">'Microsoft.XMLHTTP'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xhr.open(method, url, <span class="literal">true</span>)</span><br><span class="line">    xhr.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/x-www-form-urlencoded'</span>)</span><br><span class="line">    xhr.send(data)</span><br><span class="line"></span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span> &amp;&amp; xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(xhr.responseText)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">XMLRequest(<span class="string">'POST'</span>, <span class="string">'http://www.example.com/api'</span>, &#123;</span><br><span class="line">    name: <span class="string">'cara'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>其中 <code>readyState</code> 有五种状态:<br>0: 为初始化<br>1: 服务器连接建立<br>2: 请求已接收<br>3: 请求处理中<br>4: 请求已完成</p><h4 id="6-代理服务器"><a href="#6-代理服务器" class="headerlink" title="6. 代理服务器"></a>6. 代理服务器</h4><p>其实就是通过配置 nginx 实现一个中间服务器作跳板, 代理到目标服务器.</p><p>静态资源代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体代理配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 81;</span><br><span class="line">    server_name www.example.com;</span><br><span class="line"></span><br><span class="line">    lication / &#123;</span><br><span class="line">        # 反向代理</span><br><span class="line">        proxy_pass http://www.example2.com:8080;</span><br><span class="line">        # 修改 cookie 域名</span><br><span class="line">        proxy_cookie_domain www.example2.com www.example.com;</span><br><span class="line">        index index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 不带 cookie 时才能设置为 *</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.example.com;</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用示例<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">xhr.withCredentials = <span class="literal">true</span></span><br><span class="line">xhr.open(<span class="string">'GET'</span>, <span class="string">'htt://www.example.com:81/?user=admin'</span>, <span class="literal">true</span>)</span><br><span class="line">xhr.send(<span class="literal">null</span>)</span><br></pre></td></tr></table></figure></p><p>以上, 就是跨域导致的原因以及解决方案的大致总结.</p><p>Created on 2018-4-2 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;跨域这块是前后端分离必经的一条路, 这次好好整理一下关于跨域方面知识.&lt;/p&gt;
&lt;h3 id=&quot;什么是跨域&quot;&gt;&lt;a href=&quot;#什么是跨域&quot; class=&quot;headerlink&quot; title=&quot;什么是跨域?&quot;&gt;&lt;/a&gt;什么是跨域?&lt;/h3&gt;&lt;p&gt;跨域是受同源策略的影响而导
      
    
    </summary>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Promise 分析及实现</title>
    <link href="https://yoursite.com/2018/01/04/Promise-%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://yoursite.com/2018/01/04/Promise-分析及实现/</id>
    <published>2018-01-04T11:07:22.000Z</published>
    <updated>2018-05-13T03:49:29.856Z</updated>
    
    <content type="html"><![CDATA[<p>Promise 是 ES6中中收录的异步操作封装, 通常在回调/ 事件/ 消息等异步操作中有显著的优势, 让我们在更方便的操作异步也让代码更加清晰.包括 ES7中的 Async/Await 也是对异步操作的封装, 不过 Async 更像是 Generator 的语法糖.</p><h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>学习<a href="https://tech.meituan.com/promise-insight.html" target="_blank" rel="noopener">剖析 Promise 之基础篇</a>用一个最常见的应用来剖析 <code>Promise</code>, 通过异步获取用户 Id, 然后作一些处理. 平常我们最常用的是回调的方式来处理, 下面用 <code>Promise</code> 的方式来处理.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getUserId = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        axios.get(<span class="string">'http://example.com/api'</span>, <span class="attr">params</span>: param).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="built_in">JSON</span>.parse(res).id)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getUserId().then(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(id)</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>getUserId 函数返回一个 <code>Promise</code>, 在他的 <code>then</code> 方法中放入异步操作成功之后的回调函数. 这种方式明显比我们之前常用的回调函数更加方便而且易读, 也更加容易避免 callback hell.</p><p>那么满足这样的场景的<code>Promise</code>是怎样实现的呢, 下面我们可以简单的实现一下最基础的<code>Promise</code>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> deferreds = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 存入异步成功需要的回调函数</span></span><br><span class="line">    <span class="comment">// 此时指向两个回调函数 id =&gt; &#123;&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">        deferreds.push(onFulfilled)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 执行 deferreds 队列中的回调函数</span></span><br><span class="line">    <span class="comment">// 此时 value 为123</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        deferreds.map(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">            deferred(value)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 执行创建 Promise 实例时传入的函数</span></span><br><span class="line">    <span class="comment">// 并传入 resolve 供在适当时触发回调</span></span><br><span class="line">    fn(resolve)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUserId = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 2. 执行 resolve</span></span><br><span class="line">        resolve(<span class="number">123</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">getUserId().then( <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is callback!'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(id) <span class="comment">// 123</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is second callback!'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(id) <span class="comment">// 123</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><ul><li>调用 <code>then</code> 方法将回调函数存入 deferreds 队列.</li><li>创建 <code>Promise</code> 实例时传入函数和 <code>resolve</code>, <code>resolve</code> 用于在适当的时间触发回调函数.</li><li>真正执行回调函数的是 <code>deferreds</code> 队列中的元素.</li><li><code>resolve</code> 函数接受一个参数, 用于回调函数使用, 即异步操作的返回结果.</li></ul><p>可能大家已经发现, 以上代码并不能真正执行到回调函数.根据上面标注的序号就是代码的执行顺序, 这是因为现在还是同步函数, <code>Promise</code> 函数中的 <code>resolve</code> 函数会先于 <code>this.then</code> 函数执行,此时 <code>deferreds</code> 队列中还是空的, 以至于后面的回调函数也无法执行. 所以我们要保证回调以异步的方式执行, 以保证执行顺序. 可以通过 <code>setTimeout</code> 将 <code>resolve</code> 中的回调函数放在执行栈的末尾.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将执行的回调的逻辑放入执行栈末尾</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        deferreds.map(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">            deferred(value)</span><br><span class="line">        &#125;)    </span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在就可以看到, then 中的回调函数能够正常执行了.</p><h4 id="引入状态"><a href="#引入状态" class="headerlink" title="引入状态"></a>引入状态</h4><p>现在我们引入规范 <code>Promises/A+</code> 中所说的 States, 它有三个互斥的状态: pending/ fulfilled/ rejected.</p><p>现在我们来改进下代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> deferreds = []</span><br><span class="line">    <span class="keyword">let</span> state = <span class="string">'pending'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            deferreds.push(onFulfilled)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">        &#125;</span><br><span class="line">        onFulfilled(value)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">        value = newValue</span><br><span class="line">        state = <span class="string">'fulfilled'</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">            deferreds.map(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">                deferred(value)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fn(resolve)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="串行-Promise"><a href="#串行-Promise" class="headerlink" title="串行 Promise"></a>串行 Promise</h3><p>串行 <code>Promise</code> 是指当 promise 达到 fuifilled 状态之后, 再进行下一个 promise. 比如上例中的我们拿到 userId 之后还需要用这个 userId 去获取用户的名称/ 住址/ 手机号等其他信息.</p><p>使用的伪代码类似这样:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">getUserId()</span><br><span class="line">    .then(getUserInfoById)</span><br><span class="line">    .then(<span class="function"><span class="params">userInfo</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> getUserInfoById = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        axios.get(<span class="string">'http://example.com/api'</span>, <span class="attr">params</span>: &#123;</span><br><span class="line">            id: <span class="number">123</span></span><br><span class="line">        &#125;).then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(<span class="built_in">JSON</span>.parse(response).info)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getUserId = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(<span class="number">123</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>串行的困难在于如何将前后的 <code>Promise</code> 衔接起来, 首先对 <code>then</code> 方法改造:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// bridge promise</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        handle(&#123;</span><br><span class="line">            onFulfilled: onFulfilled || <span class="literal">null</span>,</span><br><span class="line">            resolve: resolve</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> handle = <span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        deferreds.push(deferred)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret = deferred.onFulfilled(value)</span><br><span class="line">    deferred.resolve(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li><code>then</code> 方法中返回一个新创建的 Promise 实例作为返回值, 这是串行的基础, 由于返回类型一样所以依然支持链式.</li><li><code>then</code> 方法中的形参 <code>onFulfilled</code> 和新创建的 Promise 实例中的 <code>resolve</code> 均放入当前 promise 的 deferreds 队列中.</li><li><code>handle</code> 方法作为当前 promise 的内部方法, 较之前的 <code>then</code> 方法只增加了一行<code>deferred.resolve(ret)</code>.</li></ul><p>在当前 promise 的异步成功之后执行 <code>handle</code> 方法时, 先执行 <code>onFulfilled</code> 方法, 然后将其返回值作为 <code>resolve</code> 方法的实参传入.</p><p>再改造 <code>resolve</code> 方法, 把代码整理一下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> deferreds = []</span><br><span class="line">    <span class="keyword">let</span> state = <span class="string">'pending'</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 创建一个新的 Promise作为返回值</span></span><br><span class="line">        <span class="comment">// 将当前 promise 的回调函数和新创建的 resolve</span></span><br><span class="line">        <span class="comment">// 放入 deferreds 队列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span> (<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled: onFulfilled || <span class="literal">null</span></span><br><span class="line">                resolve: resolve</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> handle = <span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化状态时, 往 deferreds 队列添加</span></span><br><span class="line">        <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            deferreds.push(deferred)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前 promise 达到 'fulfilled' 状态之后</span></span><br><span class="line">        <span class="comment">// 先执行回调函数, 再将回调函数的返回值(ret)</span></span><br><span class="line">        <span class="comment">// 传递给 resolve 函数</span></span><br><span class="line">        <span class="keyword">let</span> ret = deferred.onFulfilled(value)</span><br><span class="line">        deferred.resolve(ret)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function"><span class="params">newValue</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">'object'</span> || <span class="keyword">typeof</span> newValue === <span class="string">'function'</span>)) &#123;</span><br><span class="line">            <span class="keyword">let</span> then = newValue.then</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                then.call(newValue, resolve)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        value = newValue</span><br><span class="line">        state = <span class="string">'fulfilled'</span></span><br><span class="line">        setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">            deferreds.map(<span class="function"><span class="params">deferred</span> =&gt;</span> &#123;</span><br><span class="line">                handle(deferred)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 promise 实例中的回调函数</span></span><br><span class="line">    fn(resolve)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserId()</span><br><span class="line">    .then(getUserInfoById)</span><br><span class="line">    .then(<span class="function"><span class="params">userInfo</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'this is second callback'</span>)</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>现在 <code>resolve</code> 支持传入一个 promise 实例的参数了, 执行顺序如下:</p><ol><li><code>getUserId</code> 生成的 promise1, 进入 Promise 函数执行 <code>fn(resolve)</code> 由于<code>getUserId</code> 的内部是一个异步操作, 下一步会直接执行 <code>this.then(onFulfilled)</code>.</li><li><code>this.then()</code> 返回一个新的 promise2 函数( 即: bridge promise)作为链式调用, promise2 重新实例化再执行 <code>fn(resolve)</code>, 则进入<code>handle({...})</code> 此时 handle 的参数为 getUserInfoById 和 resolve2, 接着被 push 到 <code>deferreds1</code> 队列中; 再接着执行下一个<code>this.then()</code> 生成 promise3, <code>deferreds2</code> 队列中 push 进第二个 then 的匿名函数(userInfo =&gt; {…}) 和 resolve3.</li><li>执行<code>resolve(123)</code>, 进入 <code>resolve(newValue)</code> 执行<code>handle(deferred)</code> 此时 deferred 为 getUserInfoById 和 resolve2, 执行 handle 内部的 <code>deferred.onFulfilled(value)</code> 也就是 getUserInfoById 方法从而生成 promise4, 再到 <code>deferred.resolve(ret)</code> 这个时候 ret 就为 promise4, 传入 <code>resolve(newValue)</code> 执行 <code>then.call(promise4, resolve2)</code>.</li><li>接着上一步进入 <code>this.then()</code> 生成 promise5(bridge promise), deferred4 压入 resolve2 和 resolve5; 在执行 getUserInfoById 中的 <code>resolve({name: &#39;cara&#39;...})</code>, 进入 setTimeout 中的 <code>handle(deferred)</code>, 到 handle 函数内部 <code>deferred.onFulfilled(value)</code> 其实执行的是 <code>resolve2({...})</code> resolve2中的 <code>deferred</code> 保存的是的 <code>uerInfo =&gt; {}</code> 匿名函数和 <code>resolve3</code>; <code>deferred.resolve</code> 其实执行的是 <code>resolve5</code>, 由于 resolve3 和 resolve5 中的 <code>deferred</code> 都是空的于是完成整个流程.</li></ol><p>接下来再加入错误处理和异常判断:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> state = <span class="string">'pending'</span>,</span><br><span class="line">        value = <span class="literal">null</span>,</span><br><span class="line">        deferreds = [];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            handle(&#123;</span><br><span class="line">                onFulfilled: onFulfilled || <span class="literal">null</span>,</span><br><span class="line">                onRejected: onRejected || <span class="literal">null</span>,</span><br><span class="line">                resolve: resolve,</span><br><span class="line">                reject: reject</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">            deferreds.push(deferred);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cb = state === <span class="string">'fulfilled'</span> </span><br><span class="line">            ? deferred.onFulfilled </span><br><span class="line">            : deferred.onRejected,</span><br><span class="line">                ret;</span><br><span class="line">        <span class="keyword">if</span> (cb === <span class="literal">null</span>) &#123;</span><br><span class="line">            cb = state === <span class="string">'fulfilled'</span> </span><br><span class="line">                ? deferred.resolve </span><br><span class="line">                : deferred.reject;</span><br><span class="line">            cb(value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ret = cb(value);</span><br><span class="line">            deferred.resolve(ret);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            deferred.reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">'object'</span> || <span class="keyword">typeof</span> newValue === <span class="string">'function'</span>)) &#123;</span><br><span class="line">            <span class="keyword">var</span> then = newValue.then;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                then.call(newValue, resolve, reject);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        value = newValue;</span><br><span class="line">        finale();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        state = <span class="string">'rejected'</span>;</span><br><span class="line">        value = reason;</span><br><span class="line">        finale();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">finale</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            deferreds.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">deferred</span>) </span>&#123;</span><br><span class="line">                handle(deferred);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>之前的文字描述不好理解, 所以还是画了一个执行流程图</strong><br><img src="/img/Promise执行过程.png" alt="promise执行过程"></p><p>没有画 <code>reject</code> 的情况, 因为<code>reject</code> 跟 <code>resolve</code> 的流程是一样的, 两个一起画显得更乱就单独把 <code>resolve</code> 拎出来. 在加入 <code>handle</code> 和 <code>resolve</code> 在 promise 函数中作为内部方法后实在不易理解. 主要就是通过闭包来保存 promise 对象的变量引用, 将回调函数和 resolve 函数保存在缓存队列中, 在通过 resolve 完成链式调用.</p><h2 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h2><p>看完之前的那篇文章实在觉得有点难理解, 于是又找了其他的实现方式<a href="http://bruce-xu.github.io/blogs/js/promise" target="_blank" rel="noopener">JS Promise的实现原理</a>比之前那篇更好理解一些, 所以还是记录一下好了.</p><blockquote><p>这篇文章作者说到的 <code>Promise</code> 重点:</p><ol><li><code>Promise</code> 是一个承诺, 所以不管成功与否都要有一个执行结果, 因此 Promise 构造函数有一个函数类型的参数 <code>resolver</code> 来作为与该 promise 对象关联的任务.</li><li>三种状态不可逆转.</li><li><code>resolver</code> 函数封装了需要执行的异步操作, 内部: <code>resolve</code> 和 <code>reject</code> 两个参数; 分别代表执行成功和执行失败需要执行的操作.</li><li><code>then</code> 提供成功或失败的响应处理, 于是有了<code>onResolve</code> 和 <code>onReject</code>.</li><li><code>then</code> 方法返回一个新的 promise(bridge promise), 提供链式操作及串行, 如果直接返回 this 那么就是并行显然不符合我们的需求. 前一个 promise 需要知道下一个 promise 对象是谁及其任务引用, 而后一个 promise 要提供一个给前一个 promise 成功或失败时需要执行的任务, 因此添加一个闭包</li><li><code>makeCallback</code> 调用将 promise 及其关联任务传递进去, 返回一个新函数, 前一个 promise 对象就将持有返回函数的引用, 调用返回函数时就能访问到 promise 对象和关联任务.</li><li><code>resolve</code> 和 <code>reject</code> 函数在异步成功或失败的时候调用, 并传递成功的数据和失败的原因.</li><li><code>run</code> 函数执行异步相关的回调函数.</li></ol></blockquote><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><ul><li>构造函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">resolver</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 状态</span></span><br><span class="line">    <span class="keyword">this</span>._status = <span class="string">'pending'</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成功队列</span></span><br><span class="line">    <span class="keyword">this</span>._doneCallbacks = []</span><br><span class="line">    <span class="comment">// 失败队列</span></span><br><span class="line">    <span class="keyword">this</span>._failCallbacks = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传递关联任务</span></span><br><span class="line">    resolver(resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>then</code> 方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolve, onReject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 添加闭包调用</span></span><br><span class="line">    <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">_</span> =&gt;</span> &#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 保存对上一个 promise 的引用</span></span><br><span class="line">    <span class="keyword">this</span>._doneCallbacks.push(makeCallback(promise, onResolve, <span class="string">'reslove'</span>))</span><br><span class="line">    <span class="keyword">this</span>._failCallbacks.push(makeCallback(promise, onReject, <span class="string">'reject'</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>makeCallback</code> 函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise 对象/ 回调函数(关联任务)/ 类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCallback</span> (<span class="params">promise, callback, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">promiseCallback</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>resolve</code> 函数和 <code>reject</code> 函数<br>这两个函数都需要一个参数来接收结果, 由于状态只能转换一次所以两个函数都需要判断状态.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 成功</span></span><br><span class="line"><span class="comment">// promise: 属于哪个 promise 对象</span></span><br><span class="line"><span class="comment">// data: 异步操作的结果</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">promise, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 已经被 resolve 过的话直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (promise._status !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 修改 promise 状态</span></span><br><span class="line">    promise._status = <span class="string">'fulfilled'</span></span><br><span class="line">    <span class="comment">// 保存异步操作的值</span></span><br><span class="line">    promise._value = data</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行相关回调函数</span></span><br><span class="line">    run(promise)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败</span></span><br><span class="line"><span class="comment">// promise: 属于哪个 promise 对象</span></span><br><span class="line"><span class="comment">// reason: 失败原因</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">promise, reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise._status !== <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    promise._status = <span class="string">'rejected'</span></span><br><span class="line">    promise._value = reason</span><br><span class="line">    </span><br><span class="line">    run(promise)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>run</code> 函数<br>用来执行异步相关的回调函数.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params">promise</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// then 方法中也会调用, 此处再做一次判断</span></span><br><span class="line">    <span class="keyword">if</span> (promise._status === <span class="string">'pending'</span>) <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> value = promise._value</span><br><span class="line">    <span class="comment">// 是否成功</span></span><br><span class="line">    <span class="keyword">let</span> callbacks = promise._status === <span class="string">'fulfilled'</span></span><br><span class="line">        ? promise._doneCallbacks</span><br><span class="line">        : promise._failCallbacks</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里需要异步</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 执行回调函数</span></span><br><span class="line">        callbacks.map(<span class="function"><span class="params">cb</span> =&gt;</span> cb(value))</span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    promise._doneCallbacks = []</span><br><span class="line">    promise._failCallbacks = []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>run</code> 函数中的 callbacks 就是 <code>makeCallback</code> 所返回的函数</strong></p><ul><li>完善 <code>makeCallback</code> 函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCallback</span> (<span class="params">promise, callback, action</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">promiseCallback</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 callback 是个函数, 使用前一个 promise</span></span><br><span class="line">        <span class="comment">// 传递的值作为 callback 的参数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> callback === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> x</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                x = callback(value)</span><br><span class="line">            &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                <span class="comment">// 异常时, 用当前 promise 的 reject</span></span><br><span class="line">                reject(promise, e)</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 callback 返回的是当前的 promise</span></span><br><span class="line">            <span class="comment">// 要抛出异常</span></span><br><span class="line">            <span class="keyword">if</span> (x === promise) &#123;</span><br><span class="line">                <span class="keyword">let</span> reason = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error: return value could not be same with the promise'</span>)</span><br><span class="line">                reject(promise, reason)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果返回值是一个 promise 对象</span></span><br><span class="line">            <span class="comment">// 则当返回 promise 对象被 reoslve/ reject后</span></span><br><span class="line">            <span class="comment">// 再执行当前的 promise 的 resolve/ reject</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">                x.then(</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">                        resolve(promise, data)</span><br><span class="line">                    &#125;,</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">                        reject(promise, reason)</span><br><span class="line">                    &#125;</span><br><span class="line">                )</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> then</span><br><span class="line">                (<span class="function"><span class="keyword">function</span> <span class="title">resolveThenable</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">                    <span class="comment">// 如果返回的是一个 Thenable 对象</span></span><br><span class="line">                    <span class="keyword">if</span> (x &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            then = x.then</span><br><span class="line">                        &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                            reject(promise, e)</span><br><span class="line">                            <span class="keyword">return</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                            <span class="comment">// 调用 Thenable 对象的 then方法</span></span><br><span class="line">                            <span class="comment">// 传递进去的 resolvePromise 和 rejectPromise 以及下面两个匿名函数</span></span><br><span class="line">                            <span class="comment">// 可能会重复调用, 但是规范只能有其中一个被调用一次, 其他要被忽略</span></span><br><span class="line">                            <span class="keyword">let</span> invoked = <span class="literal">false</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                then.call(x,</span><br><span class="line">                                    <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">                                        <span class="keyword">if</span> (invoked) <span class="keyword">return</span></span><br><span class="line">                                        invoked = <span class="literal">true</span></span><br><span class="line">                                        </span><br><span class="line">                                        <span class="comment">// 避免两个 promise 恒等</span></span><br><span class="line">                                        <span class="keyword">if</span> (y === x) &#123;</span><br><span class="line">                                            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Error: return value could not be same with the promise'</span>)</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        </span><br><span class="line">                                    <span class="comment">// y 有可能还是 thenable 对象    </span></span><br><span class="line">                                    resolveThenable(y)</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                    <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">                                        <span class="keyword">if</span> (invoked) <span class="keyword">return</span></span><br><span class="line">                                        invoked = <span class="literal">true</span></span><br><span class="line">                                        </span><br><span class="line">                                        reject(promise, e)</span><br><span class="line">                                    &#125;</span><br><span class="line">                                )</span><br><span class="line">                            &#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                                    <span class="comment">// 如果`resolvePromise`和`rejectPromise`方法被调用后，再抛出异常，则忽略异常</span></span><br><span class="line">                                    <span class="comment">// 否则用异常对象reject此Promise对象</span></span><br><span class="line">                                <span class="keyword">if</span> (!invoked) &#123;</span><br><span class="line">                                    reject(promise, e)</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            resolve(promise, x)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        resolve(promise, x)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;(x))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有传 callback直接使用前一个 promise</span></span><br><span class="line">        <span class="comment">// 传过来的值 resolve/reject 当前 promise 对象</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            action === <span class="string">'resolve'</span></span><br><span class="line">                ? resolve(promise, value)</span><br><span class="line">                : reject(promise, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我一开始是先看的<strong>剖析 Promise 之基础篇</strong>, 前半部分确实很亲民, 但是到加入 <code>hanlde</code> 和改造 <code>resolve</code> 函数 就开始懵了, 然后懵懵懂懂的去看<strong>JS Promise 的原理实现</strong>, 不过在最复杂的 <code>makeCallback</code> 函数中解释有点一笔带过的意思. 不过看了这篇帮助我理解之前的<strong>剖析 Promise 之基础篇</strong>, 就返回去看基础篇画了一遍流程图才算看懂, 里面的闭包用的太精妙了.</p><blockquote><p>参考文章<br><a href="https://tech.meituan.com/promise-insight.html" target="_blank" rel="noopener">剖析 Promise 之基础篇</a><br><a href="http://bruce-xu.github.io/blogs/js/promise" target="_blank" rel="noopener">JS Promise 的原理实现</a><br><a href="https://github.com/xieranmaya/blog/issues/3" target="_blank" rel="noopener">剖析Promise内部结构</a></p></blockquote><p>Created on 2017-12-26 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Promise 是 ES6中中收录的异步操作封装, 通常在回调/ 事件/ 消息等异步操作中有显著的优势, 让我们在更方便的操作异步也让代码更加清晰.包括 ES7中的 Async/Await 也是对异步操作的封装, 不过 Async 更像是 Generator 的语法糖.&lt;/
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>《图解 HTTP》(上)</title>
    <link href="https://yoursite.com/2018/01/03/HTTP-%E4%B8%8A/"/>
    <id>https://yoursite.com/2018/01/03/HTTP-上/</id>
    <published>2018-01-03T14:03:05.000Z</published>
    <updated>2018-05-13T03:49:29.854Z</updated>
    
    <content type="html"><![CDATA[<p>Web使用HTTP(HyperText Transfer Protocal) 超文本传输协议作为规范, 完成从客户端到服务端的一系列流程. 可以说 Web 是在 HTTP 协议上通信的.</p><h3 id="1-0-网络基础TCP-IP"><a href="#1-0-网络基础TCP-IP" class="headerlink" title="1.0 网络基础TCP/IP"></a>1.0 网络基础TCP/IP</h3><p>通常我们使用的网络是在 TCP/IP 协议族的基础上运行的, 而 HTTP 是属于 TCP/IP 族群中的一种协议. 在计算机和网络相互通信的时候, 两者都必须要遵守同一种协议.</p><h4 id="1-1-TCP-IP分层管理"><a href="#1-1-TCP-IP分层管理" class="headerlink" title="1.1 TCP/ IP分层管理"></a>1.1 TCP/ IP分层管理</h4><p>TCP/IP协议族里最重要的一点就是分层, 每一层就只需要专注于自己任务就行了, 按层次分别为以下四层:</p><ol><li><p>应用层<br>决定向用户提供应用服务时的通信活动, 在 TCP/IP 中预存了各类通用的应用服务. 比如: FTP(File Transfer Protocol, 文件传输协议)和 DNS(Domain Name System, 域名系统), HTTP 协议也属于这层.</p></li><li><p>传输层<br>给两个计算机在网络中提供数据传输. TCP(传输控制协议)和 UDP(用户数据报协议)</p></li><li><p>网络层<br>处理网上流动的数据包, 决定数据通过哪条传输路线到对方计算机并把数据传输给对方.</p></li><li><p>链路层<br>处理连接网络的硬件部分. 网卡/ 驱动/ 光纤什么的</p></li></ol><h4 id="1-2-TCP-IP-传输流程"><a href="#1-2-TCP-IP-传输流程" class="headerlink" title="1.2 TCP/IP 传输流程"></a>1.2 TCP/IP 传输流程</h4><p>TCP/IP 在网络通信时, 会按照分层顺序与对方通信. 发送端从应用层往下, 接收端从应用端网上.</p><p><img src="/img/http.jpg" alt="TCP/IP传输流程"></p><h3 id="2-0-与-HTTP-关系密切的协议-IP-TCP-和-DNS"><a href="#2-0-与-HTTP-关系密切的协议-IP-TCP-和-DNS" class="headerlink" title="2.0 与 HTTP 关系密切的协议: IP/TCP 和 DNS"></a>2.0 与 HTTP 关系密切的协议: IP/TCP 和 DNS</h3><ul><li>负责传输的 IP 协议<br>将数据包传递给对方并确认到达, 确认到达的重要条件包括: IP 地址和 MAC 地址.<br><img src="/img/ip.jpg" alt="IP"></li><li>确保可靠性的 TCP 协议<br>为了方便传输将大数据包分割成以报文段为单位的数据包进行管理, 再将数据准确可靠的传递给对方. 那么如何准确可靠的传递给对方呢, 所以就有了TCP 的三次握手策略: 发送端先发送一个带有 <code>SYN</code>标志的数据包给对方, 接收端回传一个带有<code>SYN/ACK</code>标志的数据包传达确认信息, 最后发送端再回传一个带有<code>ACK</code>标志的数据包, 代表握手结束.<br><img src="/img/tcp.jpg" alt="TCP"></li><li>负责域名协议的 DNS 服务<br>提供域名到 IP 地址之间解析服务.<br><img src="/img/dns.jpg" alt="DNS"></li></ul><h4 id="2-1-HTTP-协议的通信过程"><a href="#2-1-HTTP-协议的通信过程" class="headerlink" title="2.1 HTTP 协议的通信过程"></a>2.1 HTTP 协议的通信过程</h4><p>通过一整套流程来看一下, IP协议/ TCP协议 和 DNS服务在 HTTP协议的通信过程中各自发挥了什么作用.<br><img src="/img/HTTP_IP_TCP_DNS.jpg" alt="HTTP协议通信过程"></p><p><strong>从上图来看, 从输入一个网址到页面的展示过程大致如下:</strong></p><ol><li>域名解析(DNS 服务)</li><li>建立TCP, 发送 HTTP 请求(三次握手)<ol><li>客户端向服务器发送请求(SYN)</li><li>服务器应答并要求确认(SYN/ACK)</li><li>客户端确认(ACK)</li></ol></li><li>IP 搜索对方地址, 一边中转一边传输数据包</li><li>服务器处理请求返回 HTTP 响应报文</li><li>连接结束(四次挥手)<ol><li>客户端发送一个 FIN 来告诉服务器数据发送完毕</li><li>服务器收到这个 FIN 之后回发一个 ACK(这个时候服务器还可以向客户端发送数据)</li><li>服务器发送一个 FIN 告诉客户端服务器的数据发送完毕, 请求关闭连接</li><li>客户端回发 ACK 确认, 关闭连接</li></ol></li><li>浏览器解析渲染页面</li></ol><h4 id="2-2-HTTP-是否保存状态"><a href="#2-2-HTTP-是否保存状态" class="headerlink" title="2.2 HTTP 是否保存状态"></a>2.2 HTTP 是否保存状态</h4><p>HTTP 是一种不保存状态(无状态)协议, 协议本身不会保留之前的请求或响应报文的信息. 这是为了更快的处理大量请求, 但是随着 Web 发展<br>很多业务都需要保存用户的状态, 因此引入 Cookie 来管理状态.</p><h3 id="3-0-HTTP-返回状态码"><a href="#3-0-HTTP-返回状态码" class="headerlink" title="3.0 HTTP 返回状态码"></a>3.0 HTTP 返回状态码</h3><p>状态码是用来告诉客户端从服务器响应的请求结果, 可以通过状态码知道该次请求是正常处理了还是发生了错误.</p><h4 id="3-1-状态码的类别"><a href="#3-1-状态码的类别" class="headerlink" title="3.1 状态码的类别"></a>3.1 状态码的类别</h4><table><thead><tr><th></th><th style="text-align:left">类别</th><th style="text-align:left">原因短句</th></tr></thead><tbody><tr><td>1XX</td><td style="text-align:left">信息类</td><td style="text-align:left">接收的请求正在处理</td></tr><tr><td>2XX</td><td style="text-align:left">成功类</td><td style="text-align:left">请求正常处理完毕</td></tr><tr><td>3XX</td><td style="text-align:left">重定向类</td><td style="text-align:left">需要附加操作完成请求</td></tr><tr><td>4XX</td><td style="text-align:left">客户端错误类</td><td style="text-align:left">服务器无法处理请求</td></tr><tr><td>5XX</td><td style="text-align:left">服务器错误类</td><td style="text-align:left">服务器发生错误</td></tr></tbody></table><h4 id="3-2-具有代表性的14种状态码"><a href="#3-2-具有代表性的14种状态码" class="headerlink" title="3.2 具有代表性的14种状态码"></a>3.2 具有代表性的14种状态码</h4><ul><li>2XX 成功类<ol><li>200 OK<br>表示请求在服务端被正常处理了</li><li>204  No Content<br>表示请求处理成功但是响应报文不包含实体的主体(本身也不允许返回实体的主体)</li><li>206  Partial Content<br>服务端成功处理了客户端发出的范围请求</li></ol></li><li>3XX 重定向<ol><li>301 Moved Permanently<br>永久性重定向. 请求的资源已经被分配了新的 URI 应该使用新的 URI</li><li>302 Found<br>临时性重定向. 请求的资源被分配了新的 URI, 希望本次请求用新的 URI</li><li>303 See Other<br>请求的资源存在另一个 URI, 应使用 GET 方法定向获取请求的资源(跟302的功能相同)</li><li>304 Not Modified<br>表示请求时附带了条件, 服务端允许请求资源但为满足条件. 所以返回时, 不包含任何响应的主体部分(跟重定向并没有半毛钱关系).</li><li>307 Temporary Redirect<br>临时重定向, 跟302有着同样的一样. 尽管302标准不允许 POST 变为 GET, 但是并没有人遵守; 307会遵守标准但是处理响应时, 每个浏览器有可能出现不同的情况</li></ol></li><li>4XX 客户端错误<ol><li>400 Bad Request<br>请求报文中有语法错误</li><li>401 Unauthorized<br>请求需要通过 HTTP 认证</li><li>403 Forbidden<br>请求资源访问被服务端拒绝(一般都是权限问题)</li><li>404 Not Found<br>服务端上无法找到请求的资源</li><li>405 Not Allow<br>对于请求的资源, 服务端不允许使用请求中使用的方法</li></ol></li><li>5XX 服务器错误<ol><li>500 Internal Server Error<br>服务端在执行请求任务时发生错误</li><li>503 Service Unavailable<br>服务端暂时处于超负载或者停机维护, 无法处理请求(一般就是服务器挂了)</li></ol></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>主要为了大致了解一下 HTTP 的基础/大概的执行流程和常见的HTTP 状态码. 对于状态码之前一直分不太清301和302的区别, 简单的来说: 301 改变资源的URI 后, 如果这个资源是被保存在书签中的, 那么这时要根据新的 URI 保存; 302 表示这个资源只是临时性的移动, 之后这个 URI 可能还会变化. 那么如果也被保存在了书签中, 仍然会保留原来的 URI. 状态码中的 304 放在下次放在缓存策略中再捋一捋吧.</p><p>Create on 2018-1-3 By Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Web使用HTTP(HyperText Transfer Protocal) 超文本传输协议作为规范, 完成从客户端到服务端的一系列流程. 可以说 Web 是在 HTTP 协议上通信的.&lt;/p&gt;
&lt;h3 id=&quot;1-0-网络基础TCP-IP&quot;&gt;&lt;a href=&quot;#1-0-网
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="HTTP" scheme="https://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>声明提升</title>
    <link href="https://yoursite.com/2017/12/20/%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87/"/>
    <id>https://yoursite.com/2017/12/20/声明提升/</id>
    <published>2017-12-20T13:54:07.000Z</published>
    <updated>2018-05-13T03:49:29.859Z</updated>
    
    <content type="html"><![CDATA[<p>在说声明提升之前, 首先应该了解三个概念性的东西, 执行上下文(Execution Context)/ 变量对象(Variable Object)和活动对象(Activation Object), 这三个概念是在 ES3 中出现的.</p><ul><li><p>执行上下文(Execution Context)<br>执行上下文也可以说是 js 代码的运行环境, 代码一旦被加载 js 的解释器首先进入的就是这个环境. 他有全局的执行上下文和函数的执行上下文(eval 不说, 它内部也有), js 的解释器默认先进入的是全局上下文所以我们一开始就能直接使用一些的内置方法, 比如: Array/ Number… 每当一个函数被调用时, 就会创建他自己的执行上下文, 每个执行上下文都有一个与之关联的变量对象.</p></li><li><p>作用域链(也称调用栈)<br>知道了每当一个函数调用时会创建自己的执行上下文, 这个执行上下文就会被添加到作用域链的顶端. 而解释器总是先运行作用域链顶端的执行上下文, 一旦函数调用完毕, 它的执行上下文就会从作用域链的顶端移除并将控制权交由上一个执行上下文, 直到回到全局上下文. 如下图所示:<br><img src="/img/event-loop.gif" alt="执行环境"></p></li></ul><ul><li>变量对象(Variable Object)<br>当执行上下文创建后, 进入建立阶段(函数调用, 具体代码执行之前), 在这个阶段变量对象/ 作用域链/ <code>this</code>的指向都会被确定. 变量对像会按顺序填充:</li></ul><ol><li>函数参数(没有就是 undefined)</li><li>函数声明(命名冲突, 会覆盖之前的)</li><li>变量声明(值为 undefined, 命名冲突, 会被忽略)</li></ol><ul><li>活动对象(也称激活对象)<br>函数调用活动对象就作为变量对象, 所以在函数调用时<code>变量对象 === 活动对象</code>, 活动对象会先包含<code>arguments</code>对象及方法.</li></ul><p>还是看个代码来说吧:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'hello'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">11</span>)</span><br><span class="line"><span class="comment">// 建立阶段</span></span><br><span class="line">fooExecutionContext = &#123;</span><br><span class="line">variableObject: &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">11</span>,</span><br><span class="line">length: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">i: <span class="number">11</span>, <span class="comment">// 只有参数被赋值</span></span><br><span class="line">c: pointer to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"><span class="title">a</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function"><span class="title">b</span>: <span class="title">undefined</span>,</span></span><br><span class="line"><span class="function">&#125;,</span></span><br><span class="line"><span class="function"><span class="title">scopeChain</span>: </span>&#123;...&#125;,</span><br><span class="line"><span class="keyword">this</span>: &#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行阶段</span></span><br><span class="line">fooExecutionContext = &#123;</span><br><span class="line">variableObject: &#123;</span><br><span class="line"><span class="built_in">arguments</span>: &#123;</span><br><span class="line"><span class="number">0</span>: <span class="number">11</span>,</span><br><span class="line">length: <span class="number">1</span></span><br><span class="line">&#125;,</span><br><span class="line">i: <span class="number">11</span>,</span><br><span class="line">c: pointer to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>),</span></span><br><span class="line"><span class="function"><span class="title">a</span>: '<span class="title">hello</span>', // 变量在这个时候才被赋值</span></span><br><span class="line"><span class="function"><span class="title">b</span>: <span class="title">pointer</span> <span class="title">to</span> <span class="title">function</span> <span class="title">bar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">&#125;,</span></span><br><span class="line"><span class="function"><span class="title">scopeChain</span>: </span>&#123;...&#125;,</span><br><span class="line"><span class="keyword">this</span>: &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上三个概念都无法用过代码访问, 是解释器在后台使用.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在说声明提升之前, 首先应该了解三个概念性的东西, 执行上下文(Execution Context)/ 变量对象(Variable Object)和活动对象(Activation Object), 这三个概念是在 ES3 中出现的.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;执行上下
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>事件</title>
    <link href="https://yoursite.com/2017/12/10/%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86-%E5%A7%94%E6%89%98/"/>
    <id>https://yoursite.com/2017/12/10/事件代理-委托/</id>
    <published>2017-12-10T14:05:49.000Z</published>
    <updated>2018-05-13T03:49:29.858Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript 和 HTML 交互是通过事件实现, 而事件处理程序订阅事件从而执行相应的操作.</p><h4 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h4><p>事件流描述的是 从页面接收事件的顺序.<br>事件冒泡: 从最具体的元素到最不具体的元素(从内到外); — IE<br>事件捕获: 从最不具体的元素到最具体的元素(从外到内); — Netscape<br>DOM 事件流: 先捕获后冒泡的方式.</p><p>DOM事件流包括三个阶段:</p><ol><li>捕获阶段 (IE 低版本不支持该阶段)</li><li>目标阶段 (触发事件)</li><li>冒泡阶段 (回传文档)</li></ol><h4 id="事件处理程序"><a href="#事件处理程序" class="headerlink" title="事件处理程序"></a>事件处理程序</h4><p>事件是用户或浏览器自身执行的动作, 事件处理程序(事件监听器)是响应事件的动作. 比如 click 事件的事件处理程序就是 onclick, 为事件指定处理程序的方式也有几种.</p><h5 id="HTML-事件处理程序"><a href="#HTML-事件处理程序" class="headerlink" title="HTML 事件处理程序"></a>HTML 事件处理程序</h5><p>在标签上绑定事件处理程序, HTML 和 js 紧密耦合<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">'alert('</span><span class="attr">clicked</span>')'&gt;</span>click me<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h5 id="DOM-0级事件处理程序"><a href="#DOM-0级事件处理程序" class="headerlink" title="DOM 0级事件处理程序"></a>DOM 0级事件处理程序</h5><p>将一个函数赋值给一个事件处理程序属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'clicked'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="DOM-2级事件处理程序"><a href="#DOM-2级事件处理程序" class="headerlink" title="DOM 2级事件处理程序"></a>DOM 2级事件处理程序</h5><p>定义了两个方法, 用于绑定事件处理程序和删除事件处理程序: <code>addEventListener()</code>和<code>removeEventListener()</code>. 所有的 DOM 节点都包含这两个方法, 方法有三个参数: 需要处理的事件名/ 处理函数/ 布尔值(true 为在捕获阶段调用; false 为在冒泡阶段调用)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line"><span class="comment">// 绑定处理程序</span></span><br><span class="line">btn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'clicked'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 移除处理程序(移除处理程序时, 第二个参数必须和绑定时一样)</span></span><br><span class="line">btn.removeEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'remove'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><h4 id="IE-和-DOM2级事件处理程序的区别"><a href="#IE-和-DOM2级事件处理程序的区别" class="headerlink" title="IE 和  DOM2级事件处理程序的区别"></a>IE 和  DOM2级事件处理程序的区别</h4><ul><li>IE 事件处理程序<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = docuemnt.querySelector(<span class="string">'#btn'</span>);</span><br><span class="line"><span class="comment">// 绑定事件</span></span><br><span class="line">btn.attachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// this === window</span></span><br><span class="line">alert(<span class="string">'click on IE'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 移除事件</span></span><br><span class="line">btn.detachEvent(<span class="string">'onclick'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'remove on IE'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><p><strong>以上两种事件处理程序都支持绑定多个事件, DOM2级按照顺序</strong></p><ul><li>跨浏览器事件处理<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> EventUtil = &#123;</span><br><span class="line"><span class="comment">// 绑定事件处理程序</span></span><br><span class="line">addHanlder: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">element.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">element.attachEvent(<span class="string">'on'</span> + type, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">element[<span class="string">'on'</span> + type] = handler;</span><br><span class="line">&#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">// 移除事件处理程序</span></span><br><span class="line">removeHandler: <span class="function"><span class="keyword">function</span> (<span class="params">element, type, handler</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (element.removeEventListener) &#123;</span><br><span class="line">element.removeEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (element.detachEvent) &#123;</span><br><span class="line">element.detachEvent(<span class="string">'on'</span> + type, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">element[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="事件代理-委托"><a href="#事件代理-委托" class="headerlink" title="事件代理/ 委托"></a>事件代理/ 委托</h4><p>由于事件处理程序越多, 性能越差, 所以有了事件处理程序. 事件代理的原理是基于事件的冒泡机制实现的, 由上级节点代理完成事件绑定, 优点是: </p><blockquote><p>节省内存占用, 减少事件注册. 比如在<code>ul</code>代理所有<code>li</code>的点击事件<br>动态新增子级时, 无需再次绑定事件.</p></blockquote><p>可能会提到<code>currentTarget</code>和<code>target</code>的区别: currentTarget 是注册事件时的目标(在事件处理程序中<code>this</code>始终指向 currentTarget), target 是真正触发事件的目标.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 事件注册时的元素</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.body === event.currentTarget); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">document</span>.body); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 真正点击的元素</span></span><br><span class="line"><span class="built_in">console</span>.log(event.target === <span class="built_in">document</span>.querySelector(<span class="string">'#btn'</span>)); <span class="comment">// true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>事件内置的 event 对象, 下面列举常用的几个事件对象属性:</p><ul><li>event || window.event</li><li>event.preventDefault() || window.event.cancelBubble(Boolean)<br>阻止浏览器默认事件</li><li>event.stopPropagation() || window.event.returnValue(Boolean)<br>阻止冒泡事件</li><li>event.target || winow.event.srcElement</li></ul><p>Created on 2017-12-10 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript 和 HTML 交互是通过事件实现, 而事件处理程序订阅事件从而执行相应的操作.&lt;/p&gt;
&lt;h4 id=&quot;事件流&quot;&gt;&lt;a href=&quot;#事件流&quot; class=&quot;headerlink&quot; title=&quot;事件流&quot;&gt;&lt;/a&gt;事件流&lt;/h4&gt;&lt;p&gt;事件流描述的是 
      
    
    </summary>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Flex 弹性盒子</title>
    <link href="https://yoursite.com/2017/11/23/Flex-%E5%BC%B9%E6%80%A7%E7%9B%92%E5%AD%90/"/>
    <id>https://yoursite.com/2017/11/23/Flex-弹性盒子/</id>
    <published>2017-11-23T11:15:28.000Z</published>
    <updated>2018-05-13T03:49:29.854Z</updated>
    
    <content type="html"><![CDATA[<p>Flex 是 Flexible box 的缩写(弹性布局), 用来为盒模型提供最大灵活性的布局, 更为方便的实现响应式布局.</p><blockquote><p>如何使用 Flex<br>任何一个容器都可以指定为一个 Flex 布局.  </p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 行内元素 */</span></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 内核为 webkit 的浏览器 */</span></span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="comment">/* Safari */</span></span><br><span class="line"><span class="attribute">display</span>: -webkit-flex;</span><br><span class="line"><span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设定 Flex布局之后的子元素<code>float</code>/ <code>clear</code>/ <code>vertical-align</code>都将失效.</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>所有采用 Flex 布局的的元素都称为 Flex 容器, 它的所有资源都为 Flex 容器的容器成员, 成为 Flex 项目.<br>Flex 容器都存在两根轴: 水平的主轴(main axis)和垂直的交叉轴(cross axis), 项目默认沿主轴排列. 每个项目占主轴的空间称为<code>main size</code>, 占交叉轴的空间称为<code>cross size</code>.</p><h4 id="Flex-容器的属性"><a href="#Flex-容器的属性" class="headerlink" title="Flex 容器的属性"></a>Flex 容器的属性</h4><ul><li><p>flex-direction<br>项目排列在主轴的方向 </p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>row: 默认值, 主轴为水平方向, 起点为左边</li><li>row-reverse: 主轴为水平方向, 起点为右边</li><li>column: 主轴为交叉轴方向, 起点在顶部</li><li>column-reverse: 主轴为交叉轴方向, 起点在底部</li></ul></li><li><p>flex-wrap<br>项目在主轴上的换行方式</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>nowrap: 默认值, 不换行</li><li>wrap: 换行, 第一行在上面</li><li>wrap-reverse: 换行, 第一行在下面</li></ul></li><li><p>flex-flow<br>该属性为<code>flex-direction</code>和<code>flex-wrap</code>的缩写, 默认值为<code>row nowrap</code></p></li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">flex-flow</span>: flex-direction || flex-wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>justify-content<br>项目在主轴上的对齐方式, 所以它的对齐方式跟轴的方向有关</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">justify-content</span>: flex-start | center | space-around | space-between | flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start: 默认值, 左对齐</li><li>center: 居中</li><li>space-around: 左右居中对齐, 项目之间间隔为项目与边框的间隔大一倍</li><li>space-between: 两端对齐</li><li>flex-end: 右对齐 </li></ul></li><li><p>align-items<br>项目在交叉轴在的对齐方式, 与交叉轴方向有关</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">align-items</span>: flex-start | center | baseline | stretch | flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start: 交叉轴起点对齐</li><li>center: 居中</li><li>baseline: 项目第一行文字基线对齐, 类似在文字的下划线位置</li><li>stretch: 默认值, 项目没有高度或为<code>auto</code>时, 占满整个容器</li><li>flex-end: 终点对齐</li></ul></li><li><p>align-content<br>多根轴线对齐方式. 如果项目只有一根轴线, 该属性则不起作用. 跟<code>align-items</code>容易混淆, 区别在于 <code>align-content</code>项目有多行时起作用, 而<code>align-items</code>项目单行就可起作用.</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">align-content</span>: flex-start | center | space-around | space-between | stretch | flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start: 交叉轴对齐方式</li><li>center: 居中</li><li>space-around: 左右居中对齐</li><li>space-between: 两端对齐</li><li>stretch: 默认值, 项目轴线占满整个交叉轴</li></ul></li></ul><h4 id="Flex-项目属性"><a href="#Flex-项目属性" class="headerlink" title="Flex 项目属性"></a>Flex 项目属性</h4><ul><li><p>order<br>定义项目的排列顺序, 数值越小越靠前, 默认为0</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">order</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-grow<br>定义项目的放大比例, 默认为0(有剩余空间也不放大). 如果所有项目都为1, 它们将等分剩余空间; 如果其中一个项目为2, 其它项目为1, 那么属性为2的项目占据的剩余空间将比属性为1的项目大一倍</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-shrink<br>定义项目的缩小比例, 默认为1(如果空间不足, 将缩小). 如果所有项目都为1, 当空间不足时, 所有项目都将等比例缩小; 如果其中一个项目为0, 其它项目为1, 那么当空间不足时, 前者将不缩小</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>flex-basis<br>定义属性在分配多余空间之前项目占据的主轴空间(main size). 浏览器会根据这个属性计算是否有多于空间. 默认值为 auto(项目本身的大小). 如果不使用<code>box-sizing</code>来改变盒模型的话, 该属性将决定项目的内容盒(content-box)的宽或者高(宽或高取决于主轴的方向).</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="comment">/* size 的单位可以为 px/ em/rem 百分比都行(负值无效) */</span></span><br><span class="line"><span class="attribute">flex-basis</span>: &lt;size&gt; | &lt;content&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>size: 跟宽高设置一样, 不多说.</li><li>content: css3 的几个 width 新属性. fill-available/ max-content/ min-content/ fit-content, 兼容性 IE 不支持.</li></ul></li><li><p>flex<br>该属性为<code>flex-grow</code>/<code>flex-shrink</code>和<code>flex-basis</code>的缩写, 默认值为 <code>0 1 auto</code>, 后两个属性可选</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">flex</span>: none | flex-grow flex-shrink flex-basis</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>align-self<br>允许单个项目与其他项目有不同的对齐方式, 可覆盖<code>align-items</code>属性, 默认值为 auto, 继承父级元素的<code>align-items</code>属性, 没有的话等同于<code>stretch</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">align-self: auto | flex-start | center | stretch | baseline | flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>除了 <code>auto</code>以外其他属性值跟<code>align-items</code>一样就不再重复了.</p><blockquote><p>说一下 CSS3 width 的几个新属性<br>需要带有私有前缀  </p></blockquote><ul><li>fill-available<br>让元素自动100%得填充父级宽度, 让元素表现得像块级元素一样, <code>inline-block</code>的元素也可以自动填充, 顺便再父级加一个<code>line-height</code>让元素垂直居中.</li><li>max-content<br>它的表现就像设置了<code>white-space:nowrap</code>一样, 元素的宽度取子元素中较大宽度的宽度</li><li>min-content<br>它表示的不是子元素中宽度小的那个宽度, 而是内部元素最小宽度值最大的那个元素作为最终宽度. 比如: 一个<code>div</code>中, 有一张<code>img</code>的宽度为200px, 有一个<code>p</code>里面的文字可多可少里面有英文(如果文本全是中文, 最小宽度值就是一个中文的宽度, 如果夹杂英文, 由于英文默认不换行, 所以最小宽度值是最长单词的宽度), 所以假设这里英文的最长单词不足200px, 那么最终的元素宽度就为200px</li><li>fit-content<br>设置该属性后, 不需要固定宽度, 在父级元素<code>margin: 0 auto</code>就可以实现水平居中了</li></ul><p>Created on 2017-11-23 By Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Flex 是 Flexible box 的缩写(弹性布局), 用来为盒模型提供最大灵活性的布局, 更为方便的实现响应式布局.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如何使用 Flex&lt;br&gt;任何一个容器都可以指定为一个 Flex 布局.  &lt;/p&gt;
&lt;/blockquot
      
    
    </summary>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="CSS" scheme="https://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>闭包和高阶函数</title>
    <link href="https://yoursite.com/2017/10/26/%E9%97%AD%E5%8C%85%E5%92%8C%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <id>https://yoursite.com/2017/10/26/闭包和高阶函数/</id>
    <published>2017-10-26T15:09:00.000Z</published>
    <updated>2018-05-13T03:49:29.860Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇笔记是为正式开始学习 javadcript 设计模式做铺垫，由于许多设计模式都用到了闭包和高阶函数来实现, 所以了解这两个知识点也是必要的.</p><blockquote><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包简单的来说是函数与函数之间的桥梁, 让一个函数有权访问另一个函数作用域里的变量. 定义说起来还是很生涩的, 要理解闭包我们需要先知道变量的作用域以及变量的生命周期才行.</p></blockquote><ul><li>变量的作用域<br>变量的作用域指的是变量的有效范围. 在函数中生命变量时, 如果没有关键字 var、let及const那么这个变量就会变成全局变量; 如果有这个时候的变量就是局部变量, 只有在函数内部才能够访问到.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">alert(a)</span><br><span class="line">&#125;</span><br><span class="line">fun()</span><br><span class="line">alert(a) <span class="comment">// a is not defined</span></span><br></pre></td></tr></table></figure></li></ul><p>函数这个时候就像一块单面镜, 里面可以看见外面, 外面不能看到里面. 因为函数在搜索一个变量的时候, 如果函数内没有这个变量, 那么这个搜索过程会随着代码的执行环境创建的作用域链向外搜索直至全局对象.</p><ul><li>变量生命周期<br>对于全局变量来说, 它的生命周期自然是永久的除非我们手动销毁这个变量; 对于局部变量, 一般来说当函数执行完毕之后该变量就会跟着被销毁. 而闭包则可以延续局部变量的生命周期, 举个栗子:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">a++;</span><br><span class="line">alert(a);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> fn = func();</span><br><span class="line">fn(); <span class="comment">// 1</span></span><br><span class="line">fn(); <span class="comment">// 2</span></span><br><span class="line">fn(); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li></ul><p>这里我们可以看到 a 变量不仅在外部可以被访问到而且还一直在递增, 这是因为 <code>fn = func()</code>执行时, fn 保存了 func 返回的匿名函数, 而这个匿名函数是有权 func() 被调用时产生的环境. a 变量就在这个环境中, 所以既然局部变量所在换的环境没有被销毁那么 a 变量也不会被销毁掉, 这个例子就产生了一个闭包结构.</p><blockquote><h4 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h4></blockquote><ul><li>封装变量<br>众所周知全局变量是非常容易引起命名冲突的, 所以我们可以利用闭包把一些不需要暴露在全局的变量封装成私有变量.</li></ul><p>假设有一个计算乘积的函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mult = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 缓存(封装起来)</span></span><br><span class="line"><span class="keyword">let</span> cache = &#123;&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> arg = [].join.call(<span class="built_in">arguments</span>, <span class="string">','</span>)</span><br><span class="line"><span class="comment">// 封装计算方法</span></span><br><span class="line"><span class="keyword">let</span> calulate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">a = a * <span class="built_in">arguments</span>[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 存在缓存则不计算</span></span><br><span class="line"><span class="keyword">if</span> (arg <span class="keyword">in</span> cache) <span class="keyword">return</span> cache[arg]</span><br><span class="line"><span class="keyword">return</span> cache[arg] = calulate.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mult(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></p><p>将变量 cache 封装在 mult 函数中来缓存已经计算过的参数, 以减少重复计算. 这个缓存机制本来是可以扔在全局环境中的.</p><ul><li>延续局部变量生命周期<br>平常做埋点会用到的 image 对象来上报数据, 如下:</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> report = <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = src</span><br><span class="line">&#125;</span><br><span class="line">report(<span class="string">'http://xxxxx.com/xxx'</span>)</span><br></pre></td></tr></table></figure><p>这种写法会造成数据丢失, 因为在 HTTP 还未结束时, report 函数已经执行完毕而 img 为 report 函数中的局部变量, 在函数执行完毕后就会随之销毁造成数据丢失的情况. 下面用闭包把变量封装起来, 来解决这一问题:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> report = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> imgs = []</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">src</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">imgs.push(img);</span><br><span class="line">img.src = src</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line">report(<span class="string">'http://xxxxx.com/xxx'</span>)</span><br></pre></td></tr></table></figure></p><blockquote><h4 id="闭包实现命令模式"><a href="#闭包实现命令模式" class="headerlink" title="闭包实现命令模式"></a>闭包实现命令模式</h4><p>说了这么多就来看看关于闭包的运用吧, 这里用闭包简单实现下命令模式, 顺便预先了解一下命令模式.</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'open'</span> <span class="attr">onclick</span>=<span class="string">'execute'</span>&gt;</span>执行命令<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">'close'</span> <span class="attr">onclick</span>=<span class="string">'undo'</span>&gt;</span>撤销命令<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>面向对象版<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TV = &#123;</span><br><span class="line">open () &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'TV is open!'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">close () &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'TV is close!'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接收命令</span></span><br><span class="line"><span class="keyword">const</span> ReceiveCommand = <span class="function"><span class="params">receiver</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.receiver = receiver</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开电视</span></span><br><span class="line">ReceiveCommand.prototype.execute = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.receiver.open()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关电视</span></span><br><span class="line">ReceiveCommand.prototype.undo = functon () &#123;</span><br><span class="line"><span class="keyword">this</span>.receiver.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置命令</span></span><br><span class="line"><span class="keyword">const</span> setCommand = <span class="function"><span class="keyword">function</span> (<span class="params">command</span>) </span>&#123;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'open'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">command.execute()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'close'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">command.undo()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将命令告诉执行者, 设置命令传入执行者</span></span><br><span class="line">setCommand(<span class="keyword">new</span> ReceiveCommand(TV))</span><br></pre></td></tr></table></figure></li></ul><p>命令模式是把请求发起者和执行命令(执行者)分离开来, 以达到解耦的目的. 在执行命令之前, 把命令放入执行者来告诉执行者要执行什么样的命令, 命令模式大概就是这样啦.</p><ul><li>闭包版<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TV = &#123;</span><br><span class="line">open () &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'TV is open!'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">close () &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'TV is close!'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行者</span></span><br><span class="line"><span class="keyword">const</span> receiveCommand = <span class="function"><span class="params">receiver</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> execute = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> receiver.open()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> undo = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> receiver.close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">execute: execute,</span><br><span class="line">undo: undo</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发起者</span></span><br><span class="line"><span class="keyword">const</span> setCommand = <span class="function"><span class="params">command</span> =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'open'</span>).onclick = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">execute.open()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'close'</span>).onclick = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">undo.close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">setCommand(receiveCommand(TV))</span><br></pre></td></tr></table></figure></li></ul><p>闭包明显清晰更多, 也更简洁.</p><blockquote><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>将函数作为参数传递或让函数执行结果返回另一个函数, 满足这两个条件之一的函数都可以称作为高阶函数.</p></blockquote><h4 id="将函数作为参数传递"><a href="#将函数作为参数传递" class="headerlink" title="将函数作为参数传递"></a>将函数作为参数传递</h4><p>将函数作为参数传递, 就意味着我们可以将与业务相关的逻辑代码分离出来, 解除业务代码和不变逻辑的耦合, 最常见的就是我们的回调函数. 实际运用中 ajax 异步请求, 当我们不知道返回值在什么时候返回值又需要在返回后做一些处理, 就要用到回调函数了.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> getPersonInfo = <span class="function"><span class="keyword">function</span> (<span class="params">userId, callback</span>) </span>&#123;</span><br><span class="line">$.ajax(<span class="string">`http://xxx/getPersonInfo?<span class="subst">$&#123;userId&#125;</span>`</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">callback &amp;&amp; callback(data)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里的匿名函数就是上面的 callback</span></span><br><span class="line">getPersonInfo(<span class="string">"54332123"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种是我们比较常见的回调函数, 在其他的方面, 也可以将一些请求委托给另一个函数代为执行, 如:<br>假如我们需要先创建100的 div 节点, 然后把它们隐藏掉</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count 默认值为100</span></span><br><span class="line"><span class="keyword">const</span> appendDiv = count = <span class="number">100</span>, callback =&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (count &amp;&amp; <span class="keyword">typeof</span> count === <span class="string">'number'</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line"><span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">div.innerHTML = i</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line"><span class="comment">// 将业务代码委托执行</span></span><br><span class="line">callback &amp;&amp; callback(div)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 把改变样式的业务逻辑分离出来</span></span><br><span class="line">appendDiv(<span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">el.style.cssText = <span class="string">`display: none`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样我们就将业务逻辑分离出来了, 以后可能我们想改颜色啦或者位置什么的也方便维护.</p><h4 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h4><p>相比把函数作为参数传递, 可能函数当做返回值返回运用场景更多一些, 让函数返回另一个可执行函数就意味着运算过程可延续.直接来看一些例子吧.</p><ul><li>检查类型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Type = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, type; type = [<span class="string">'Array'</span>, <span class="string">'String'</span>, <span class="string">'Number'</span>][i++];) &#123;</span><br><span class="line">Type[<span class="string">'is'</span> + type] = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object '</span>+ type +<span class="string">']'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Type.isArray([])) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Type.isString(<span class="string">'123'</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(Type.isNumber(<span class="number">123</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><ul><li>单例模式<br>  这里先不讨论单例模式, 只看代码实现</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fn 函数作为参数传递</span></span><br><span class="line"><span class="keyword">const</span> getSingle = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> ret;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 如果 ret 不存在, ret 等于 fn 函数</span></span><br><span class="line"><span class="keyword">return</span> ret || (ret = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 调用这个高阶函数</span></span><br><span class="line"><span class="keyword">let</span> getDiv = getSingle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// 参数也会一起传过来, 这里返回['123']</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">getDiv(<span class="string">'123'</span>)</span><br></pre></td></tr></table></figure><p>getSingle 这个高阶函数既将函数作为参数传递, 又让函数执行后返回另一个函数.</p><blockquote><p>JavaScript 设计模式与开发实践还有个例子也很有意思<br>叫做 AOP(面向切面编程), 作用是把与业务逻辑不相关的部分抽离出来再通过动态植入的方式加入业务逻辑的模块中.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在原函数之前</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> that = <span class="keyword">this</span>; <span class="comment">// 保存原函数的引用</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// A</span></span><br><span class="line"><span class="comment">// 执行新函数并修正 this</span></span><br><span class="line">beforeFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line"><span class="comment">// 执行原函数</span></span><br><span class="line"><span class="keyword">return</span> that.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在原函数之后</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// B</span></span><br><span class="line"><span class="comment">// 先执行 before 函数</span></span><br><span class="line">that.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line"><span class="comment">// 再执行新函数</span></span><br><span class="line"><span class="keyword">return</span> afterFn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">fn = fn.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fn() <span class="comment">// 按顺序输出 1 2 3</span></span><br></pre></td></tr></table></figure><p>上面的执行顺序是这样的:</p><ol><li>After中的回调函数 B<br>因为在最后执行 fn 函数时, fn 已经是 after 函数了, 因此在 fn() 执行时调用的是 after 中返回的匿名函数B.</li><li>B 中的 that.apply(this, arguments)<br>此时的 that 指向 before 函数</li><li>执行Before中的回调函数 A</li><li>A 中的 beforeFn.apply(this, arguments)<br>执行 console.log(1)</li><li>return that.apply(this, arguments)<br>执行 console.log(2)</li><li>回到 after 函数中执行return afterFn.apply(this, arguments)<br>执行 console.log(3)</li></ol><h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>函数柯里化可以说是高阶函数经典中的经典了, 说到高阶函数应该很快就会想到他了. 我理解的函数柯里化是: 先将参数依次缓存, 在真正需要计算结果时, 才进行计算这样可以减少运算次数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用 curring</span></span><br><span class="line"><span class="keyword">const</span> curring = <span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> argsArr = []</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [...args].length === <span class="number">0</span></span><br><span class="line">            ? fn.apply(<span class="literal">null</span>, argsArr)</span><br><span class="line">            : [].push.apply(argsArr, [...args])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要计算的函数</span></span><br><span class="line"><span class="keyword">let</span> calculate = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> money = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...argsArr</span>) =&gt;</span> &#123;</span><br><span class="line">        argsArr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            money += item</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> money</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 柯里化</span></span><br><span class="line">calculate = curring(calculate)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存参数, 其实并没有计算</span></span><br><span class="line">calculate(<span class="number">20</span>)</span><br><span class="line">calculate(<span class="number">40</span>)</span><br><span class="line">calculate(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正计算的时候</span></span><br><span class="line">calculate()</span><br></pre></td></tr></table></figure><h4 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h4><p>在某些场景下函数有可能会被非常频繁地调用, 从而造成很大的性能问题. 例如: window.resize事件、mousemove 事件, 它们触发的频率太高了, 而用户并不需要如此高频率的使用. 因此函数节流就是为了限制函数出发的频率.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节流</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, interval = <span class="number">800</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> isFirst = <span class="literal">true</span>, timer</span><br><span class="line">    <span class="comment">// ...args =&gt; event</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> that = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">if</span> (isFirst) &#123;</span><br><span class="line">            fn.apply(that, [...args])</span><br><span class="line">            <span class="keyword">return</span> isFirst = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timer) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            clearTimeout(timer)</span><br><span class="line">            timer = <span class="literal">null</span></span><br><span class="line">            fn.apply(that, [...args])</span><br><span class="line">        &#125;, interval)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入需要节流的函数和间隔时间</span></span><br><span class="line"><span class="built_in">window</span>.onresize = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;, <span class="number">800</span>)</span><br></pre></td></tr></table></figure><h4 id="分时函数"><a href="#分时函数" class="headerlink" title="分时函数"></a>分时函数</h4><p>上面我们提供了一种限制函数调用频率的解决方案, 现在是另一个问题: 某些函数是由用户主动唤起的, 但是因为一些原因导致函数严重影响页面的性能. 分时函数可以为我们解决这个问题, 我理解的分时函数: 将请求分批处理, 在一定的时间内执行一部分请求, 直到请求全部完成.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分时函数</span></span><br><span class="line"><span class="keyword">const</span> timeChunk = <span class="function">(<span class="params">data, fn, count = <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> timer, obj</span><br><span class="line">    <span class="keyword">const</span> start = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">Math</span>.min(count, data.length); i++) &#123;</span><br><span class="line">            obj = data.shift()</span><br><span class="line">            fn.apply(<span class="literal">null</span>, obj)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.length === <span class="number">0</span>) &#123;</span><br><span class="line">            clearTimeout(timer)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            start()</span><br><span class="line">        &#125;, <span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟数据</span></span><br><span class="line"><span class="keyword">let</span> ary = []</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    ary.push(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分时化</span></span><br><span class="line"><span class="keyword">let</span> renderfriendList = timeChunk(ary, <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    div.innerHTML = n</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div)</span><br><span class="line">&#125;, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染</span></span><br><span class="line">renderfriendList()</span><br></pre></td></tr></table></figure><h4 id="惰性加载"><a href="#惰性加载" class="headerlink" title="惰性加载"></a>惰性加载</h4><p>举个例子, 在 web 中为了满足各浏览器之间的差异, 我们会做一些嗅探工作. 异于常规方案, 惰性加载在真正需要时才使用且进入条件分支后在内部重写该函数, 这样重写后的函数就是我们需要的函数.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> addEvent = <span class="function">(<span class="params">el, type, handler</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">        <span class="comment">// 重写函数</span></span><br><span class="line">        addEvent = <span class="function">(<span class="params">el, type, handler</span>) =&gt;</span> &#123;</span><br><span class="line">            el.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.attachEvent) &#123;</span><br><span class="line">        addEvent = <span class="function">(<span class="params">el, type, handler</span>) =&gt;</span> &#123;</span><br><span class="line">            el.attachEvent(<span class="string">'on'</span> + type, handler)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addEvent(el, type, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">addEvent(btn, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'click!'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Created on 2017-10-26 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这一篇笔记是为正式开始学习 javadcript 设计模式做铺垫，由于许多设计模式都用到了闭包和高阶函数来实现, 所以了解这两个知识点也是必要的.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;闭包&quot;&gt;&lt;a href=&quot;#闭包&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
      <category term="JavaScript设计模式" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>base64 转 blob</title>
    <link href="https://yoursite.com/2017/10/22/base64-%E8%BD%AC-blob/"/>
    <id>https://yoursite.com/2017/10/22/base64-转-blob/</id>
    <published>2017-10-22T13:44:12.000Z</published>
    <updated>2018-05-13T03:49:29.856Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = base64.split(<span class="string">','</span>), mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>],</span><br><span class="line">    bstr = atob(arr[<span class="number">1</span>]), n = bstr.length, u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        <span class="comment">// charCodeAt() 方法可返回指定位置的字符的 Unicode 编码</span></span><br><span class="line">        u8arr[n] = bstr.charCodeAt(n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 'application/octet-binary' (默认值)</span></span><br><span class="line"><span class="keyword">let</span> blob = <span class="keyword">new</span> Blob([u8arr], &#123; <span class="attr">type</span>: mime &#125;)</span><br></pre></td></tr></table></figure><h4 id="Base64-的编码码和解码"><a href="#Base64-的编码码和解码" class="headerlink" title="Base64 的编码码和解码"></a>Base64 的编码码和解码</h4><p>使用atob 和 btoa 方法.</p><ul><li>atob() 解码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">atob(<span class="string">"amF2YXNjcmlwdA=="</span>)</span><br><span class="line"><span class="comment">// 解码结果 "javascript"</span></span><br></pre></td></tr></table></figure><ul><li>btoa() 编码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa(javascript)</span><br><span class="line"><span class="comment">// 转码结果 "amF2YXNjcmlwdA=="</span></span><br></pre></td></tr></table></figure><p>以上两种方法对于中文是有局限性的, 解决如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"China，中国"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先用 encodeURI() 编码</span></span><br><span class="line"><span class="built_in">window</span>.btoa(<span class="built_in">window</span>.encodeURIComponent(str))</span><br><span class="line"><span class="comment">// "Q2hpbmElRUYlQkMlOEMlRTQlQjglQUQlRTUlOUIlQkQ="</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// atob 解码 Base64 再用 decodeURI() 解码</span></span><br><span class="line"><span class="built_in">window</span>.decodeURIComponent(<span class="built_in">window</span>.atob(<span class="string">'Q2hpbmElRUYlQkMlOEMlRTQlQjglQUQlRTUlOUIlQkQ='</span>))</span><br><span class="line"><span class="comment">// "China，中国"</span></span><br></pre></td></tr></table></figure><p>Created on 2017-9-4 by Cara*</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>盒模型</title>
    <link href="https://yoursite.com/2017/10/21/%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
    <id>https://yoursite.com/2017/10/21/盒模型/</id>
    <published>2017-10-21T15:58:06.000Z</published>
    <updated>2018-05-13T03:49:29.859Z</updated>
    
    <content type="html"><![CDATA[<p><code>CSS</code> 盒模型 (Box Model), 包含的要素分别为: content/padding/border/margin.</p><h3 id="标准盒模型-amp-怪异盒模型"><a href="#标准盒模型-amp-怪异盒模型" class="headerlink" title="标准盒模型 &amp; 怪异盒模型"></a>标准盒模型 &amp; 怪异盒模型</h3><p>盒模型分为W3C的标准盒模型和IE的标准盒模型.</p><ul><li><p>标准盒模型<br><code>content + padding+ border + margin</code>  标准盒模型的 content 是不包含其他部分的, 如下图:<br><img src="http://orf90agxq.bkt.clouddn.com/GitHub/boxW3C_BOX.jpeg" alt="W3C-BOX"></p></li><li><p>IE标准盒模型<br><code>content(padding + border) + margin</code> 而IE标准盒模型的 content 已经包含padding和border的值, 如下图:<br><img src="http://orf90agxq.bkt.clouddn.com/GitHub/boxIE_BOX.jpeg" alt="IE-BOX"></p></li></ul><p>在文档顶部声明 <code>DOCTYPE</code> 就是为了让浏览器使用 W3C标准盒模型, 但是在 IE5/ IE6 下依然是 IE 标准盒模型. 当然通过<code>box-sizing</code>属性可以在两者之间转换.</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ol><li><p>两个垂直方向相邻的块级元素相遇时, 外边距会合并且取值两者较大值的 <code>margin</code> 作为外边距.</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">解决方案:</span><br><span class="line"> *&#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>margin 出轨…<br>当父元素没有 <code>border</code> 边框时, 第一个子元素添加 <code>margin-top</code> 会超出父元素, 相同最后一个子元素添加 <code>margin-bottom</code> 也同样会超出父元素, 如下图: </p></li></ol><ul><li><p>第一个子元素添加 margin-top<br><img src="http://orf90agxq.bkt.clouddn.com/box_modelmargin.png" alt="marginTop"></p></li><li><p>最后一个子元素添加 margin-bottom<br><img src="http://orf90agxq.bkt.clouddn.com/box_modelmarginBottom.png" alt="marginBottom"></p></li><li><p>前两者同时存在时, 父元素添加 border<br><img src="http://orf90agxq.bkt.clouddn.com/box_modelborder.png" alt="marginBottom"></p></li></ul><p>解决方案有四种: </p><blockquote><ol><li>给父元素添加 border.</li></ol></blockquote><blockquote><ol start="2"><li>给父元素添加 padding.</li></ol></blockquote><blockquote><ol start="3"><li>给父元素添加 overflow: hidden.</li></ol></blockquote><blockquote><ol start="4"><li>给父元素添加伪类. (最佳)<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>Created on 2017-8-15 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;CSS&lt;/code&gt; 盒模型 (Box Model), 包含的要素分别为: content/padding/border/margin.&lt;/p&gt;
&lt;h3 id=&quot;标准盒模型-amp-怪异盒模型&quot;&gt;&lt;a href=&quot;#标准盒模型-amp-怪异盒模型&quot; class=
      
    
    </summary>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="CSS" scheme="https://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>位运算符</title>
    <link href="https://yoursite.com/2017/10/18/%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://yoursite.com/2017/10/18/位运算符/</id>
    <published>2017-10-18T15:06:59.000Z</published>
    <updated>2018-05-13T03:49:29.858Z</updated>
    
    <content type="html"><![CDATA[<p>在C或者其他语言数值的运算其实都是先将数值转换为二进制在做运算的,<br>而位运算符就是直接进行二进制运算, 因此速度会非常快. 但是对于JavaScript<br>来说, 执行环境一般接触不到硬件, 所以性能完全不能和其他语言相比. 不过作为<br>了解还是需要的, 只对较为常见的位运算符作记录.</p><h3 id="位运算-NOT"><a href="#位运算-NOT" class="headerlink" title="位运算 NOT"></a>位运算 NOT</h3><p>位运算 NOT 由 ( ~ ) 符号表示, 其实就是对数值求负之后再减一, 如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = ~num;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ~num 效果同下</span></span><br><span class="line">num2 = -num - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num2); <span class="comment">// -11</span></span><br></pre></td></tr></table></figure><h3 id="左位移运算"><a href="#左位移运算" class="headerlink" title="左位移运算"></a>左位移运算</h3><p>左位移运算由 ( &lt;&lt; ) 符号表示. 将数值的所有位向左移动指定数量.例如:<br>左移一位乘2, 左移2位乘4, 以此类推.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num &lt;&lt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 效果同下</span></span><br><span class="line"> num2 = num * <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num2); <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h3 id="有符号右移运算"><a href="#有符号右移运算" class="headerlink" title="有符号右移运算"></a>有符号右移运算</h3><p>有符号右移运算符由 ( &gt;&gt; ) 符号表示, 将数值的所有为向右移动指定位数,<br>同时保留该数的符号 (正号或者负号) . 有符号右移运算符跟左位移运算符正好<br>相反.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">let</span> num2 = num &gt;&gt; <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 效果同下</span></span><br><span class="line">num2 = num / <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(num2) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="无符号右位移运算符"><a href="#无符号右位移运算符" class="headerlink" title="无符号右位移运算符"></a>无符号右位移运算符</h3><p>无符号运算符由 ( &gt;&gt;&gt; ) 符号表示, 对于正数无符号右位移运算符跟无符号右位移<br>运算符规则相同; 负数时会出现无限大的数值, 所以决定使用无符号右位移运算符<br>时一定要小心.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在C或者其他语言数值的运算其实都是先将数值转换为二进制在做运算的,&lt;br&gt;而位运算符就是直接进行二进制运算, 因此速度会非常快. 但是对于JavaScript&lt;br&gt;来说, 执行环境一般接触不到硬件, 所以性能完全不能和其他语言相比. 不过作为&lt;br&gt;了解还是需要的, 只对
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>this/ call and apply</title>
    <link href="https://yoursite.com/2017/10/17/this-call-and-apply/"/>
    <id>https://yoursite.com/2017/10/17/this-call-and-apply/</id>
    <published>2017-10-17T15:01:38.000Z</published>
    <updated>2018-06-18T15:39:45.431Z</updated>
    
    <content type="html"><![CDATA[<p>在 JavaScript 中, <code>this</code>关键字很容易使大家疑惑, 再加上 <code>Function.prototype.call</code>和<code>Function.prototype.apply</code>这两个方法的广泛运用, 所以很有必要弄清<code>this</code>的使用.</p><blockquote><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>首先先说一下<code>this</code>的概念: <code>this</code>总是指向一个对象, 而这个对象具体是谁, 是根据运行时的函数执行的环境动态绑定的, 而非函数被声明时的环境. 当然到现在箭头函数的出现, <code>this</code>对不了解的同学们来说, 无疑是添了一把乱… 接下来我们一个一个的来说吧.</p></blockquote><h4 id="1-this的指向"><a href="#1-this的指向" class="headerlink" title="1. this的指向"></a>1. <code>this</code>的指向</h4><p>我们除开不常用的 with 和 eval 的情况, 具体到实际应用中, <code>this</code>的指向大致可以分为以下四种情况.</p><ul><li>作为对象的方法被调用</li><li>作为普通函数被调用</li><li>构造器调用</li><li><p>被 call 和 apply 方法调用<br>下面来用 &lt; JavaScript 设计模式 &gt; 中的例子说明这四种情况.</p><ol><li><p>作为对象方法调用<br>当函数作为对象的方法被调用时, <code>this</code>指向该对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'cara'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span> === obj)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.getName() <span class="comment">// true 'cara'</span></span><br></pre></td></tr></table></figure></li><li><p>作为普通函数调用<br>当函数不作为对象的方法被调用时, 也就是我们平常说的普通函数的方式, 此时的<code>this</code>总是指向全局对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">let</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getName()) <span class="comment">// 'window'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里 obj 的 getName方法赋值给了一个变量</span></span><br><span class="line"><span class="comment">// 调用的时候就只会作为一个普通函数调用</span></span><br><span class="line"><span class="keyword">let</span> getName = obj.gatName;</span><br><span class="line"><span class="built_in">console</span>.log(getName()) <span class="comment">// 'window'</span></span><br></pre></td></tr></table></figure><p>上面这中作为普通函数调用的方式常常会带来一些困扰, 比如在某个 div 节点的事件函数中, 定义了一个局部的 callback 方法. 而这个 callback 方法我们往往是想让它的 <code>this</code>指向 div 节点, 但它内部却指向<code>window</code>. 如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'div1'</span>&gt;</span>我是一个 div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.id = <span class="string">'window'</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id); <span class="comment">// 'div1'</span></span><br><span class="line">    <span class="keyword">let</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.id); <span class="comment">// 'window'</span></span><br><span class="line">    &#125;</span><br><span class="line">    callback() <span class="comment">// 作为普通函数被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要解决以上问题其实也很简单, 如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.id = <span class="string">'window'</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>).onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.id);</span><br><span class="line">    <span class="keyword">let</span> that = <span class="keyword">this</span>; <span class="comment">// 用一个变量来储存节点的引用</span></span><br><span class="line">    <span class="keyword">let</span> callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(that.id); <span class="comment">// 'div1'</span></span><br><span class="line">    &#125;</span><br><span class="line">    callback() <span class="comment">// 作为普通函数被调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造器调用<br>先说说构造器吧, js 中没有类的概念, 但是可以从构造器中创建对象, 同时提供 <code>new</code> 运算符, 让构造器看起来更像一个类. Js 中大部分函数都可以当做构造器来使用, 所以它的外表看起来跟普通函数一样, 区别在于被调用的方式. 当用 <code>new</code> 运算符调用时, 该函数会返回一个对象. 通常情况下, 构造器里的 <code>this</code> 就指向返回的这个对象, 如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Myobj = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'cara'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Myobj();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 'cara'</span></span><br></pre></td></tr></table></figure><p>但是使用 <code>new</code>调用构造器时, 要注意一个问题. 如果构造器显式地返回了一个对象, 那么最终就会返回这个对象, 而不是我们的期望的 <code>this</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Myobj = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'cara'</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        name: <span class="string">'somebody'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> Myobj();</span><br><span class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// 'somebody'</span></span><br></pre></td></tr></table></figure><p>如果构造器不显式地返回任何数据或是返回一个非对象类型的数据, 就不会出现上述情况</p></li><li><p>call 或 apply 方法调用<br>跟普通的函数调用相比, 用 call 或者 apply 方法调用可以动态地改变传入函数的 <code>this</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;</span><br><span class="line">    name: <span class="string">'cara'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj2 = &#123;</span><br><span class="line">    name: <span class="string">'ben'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// 'cara'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name.call(obj2)); <span class="comment">// 'ben'</span></span><br></pre></td></tr></table></figure><p>call 和 apply 方法能够很好的体现 js 的函数式语言特性. 在 js 中几乎每一次编写函数式语言风格的代码都离不开 call 和 apply.</p></li></ol></li></ul><h4 id="2-丢失的-this"><a href="#2-丢失的-this" class="headerlink" title="2. 丢失的 this"></a>2. 丢失的 this</h4><p>这是一个经常遇到的问题, 在刚刚开始学习 js 时,<code>this</code>的指向常常令我疑惑, 尤其是看到网上关于<code>this</code>指向的题目, 简直云里雾里. 下面就来看一些例子吧!</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'apple'</span>,</span><br><span class="line">    getName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.getName()); <span class="comment">// 'apple'</span></span><br><span class="line"><span class="keyword">let</span> getMyName = obj.getName;</span><br><span class="line"><span class="built_in">console</span>.log(getMyName()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>上面这个例子好理解, 就是通过一个变量来引用<code>obj.getName</code>方法, 并且调用 getMyName 时, 就是用的普通函数调用方式, <code>this</code>是指向全局 window 的.</p><pre><code>接下来再来看一个稍微复杂一点的例子吧:</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'window'</span>;</span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name: <span class="string">'person'</span>,</span><br><span class="line">    showName1: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;,</span><br><span class="line">    showName2: <span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name),</span><br><span class="line">    showName3: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    showName4: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> person2 = &#123;<span class="attr">name</span>: <span class="string">'person2'</span>&#125;;</span><br><span class="line"></span><br><span class="line">person.showName1();</span><br><span class="line">person.showName1().call(person2);</span><br><span class="line"></span><br><span class="line">person.showName2();</span><br><span class="line">person.showName2().call(person2);</span><br><span class="line"></span><br><span class="line">person.showName3()();</span><br><span class="line">person.showName3().call(person2);</span><br><span class="line">person.showName3.call(person2)();</span><br><span class="line"></span><br><span class="line">person.showName4()();</span><br><span class="line">person.showName4().call(person2);</span><br><span class="line">person.showName4.call(person2)();</span><br></pre></td></tr></table></figure><p>这个例子可能大家已经很眼熟了, 不过当时我第一次做的时候几乎错了一大半😒…. 现在再拿出来看看其实还是很经典的: 在 person 和 person2 之间疯狂玩 showName 方法. 在给出答案之前我们先看看箭头函数的一些特点:</p><ul><li>箭头函数不可用作构造函数.</li><li>不可以使用 <code>arguments</code>对象, 如果要用可以使用 rest 参数代替.</li><li>不能使用<code>yield</code>命令, 所以箭头函数也不能作为 Generator 函数.</li><li><p>箭头函数的<code>this</code>是定义时所在的对象, 而不是执行时所在的对象.</p><p>  在最后一点的<code>this</code>指向上, 我个人觉得有点误导(也可能是我没理解到位)… 因为如果在对象字面量中的方法是通过箭头函数定义的话, <code>this</code>的指向就会和你期望的不一样了. </p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'window'</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    name: <span class="string">'obj'</span>,</span><br><span class="line">    getName: <span class="function"><span class="params">_</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">obj.getName(); <span class="comment">// 'window'</span></span><br></pre></td></tr></table></figure><p>所以我觉得关于理解箭头函数<code>this</code>在定义时所在的对象是这样: <code>this</code>继承自父级的执行上下文(简单对象即非函数, 是没有执行上下文的), 所以上面例子就是 getName 方法的父级是 obj, 而 obj 的执行上下文是<code>window</code>, 因此输出全局对象的 name. 理解了关于箭头函数<code>this</code>的指向, 现在再来看看答案吧:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">person.showName1(); <span class="comment">// 'person'</span></span><br><span class="line">person.showName1().call(person2); <span class="comment">//  'person2'</span></span><br><span class="line"></span><br><span class="line">person.showName2(); <span class="comment">// 'window'</span></span><br><span class="line">person.showName2().call(person2); <span class="comment">// 'window'</span></span><br><span class="line"></span><br><span class="line">person.showName3()(); <span class="comment">// 'window'</span></span><br><span class="line">person.showName3().call(person2); <span class="comment">// 'person2'</span></span><br><span class="line">person.showName3.call(person2)(); <span class="comment">// 'window'</span></span><br><span class="line"></span><br><span class="line">person.showName4()(); <span class="comment">// 'person'</span></span><br><span class="line">person.showName4().call(person2); <span class="comment">// 'person'</span></span><br><span class="line">person.showName4.call(person2)(); <span class="comment">// 'perons2'</span></span><br></pre></td></tr></table></figure><p>然后来分析一下答案吧:</p><ul><li><p>调用 showName1()<br>这两个方式好理解, 第一种是通过 person 对象来调用的 showName1 方法, 也就是上面我们说过的<strong>作为对象的方法被调用</strong>, 所以<code>this</code>自然指向的是person 对象; 第二种是<strong>被 call 和 apply 方法调用</strong>, 所以<code>this</code>指向的是被 call 方法矫正的 person2.</p></li><li><p>调用 showName2()<br>showName2 方法是一个箭头函数, 根据我们之前说过的箭头函数指向问题来看. 第一种通过 person 对象来调用, 由于 person 是一个简单对象所以这里它的执行上下文就是<code>window</code>, 那么就是作为普通函数调用, <code>this</code>指向 <code>window</code>; 第二种跟第一种是相同的调用方式, 只是把 person 对象换为 person2.</p></li><li><p>调用 showName3()<br>Person.showName3 是一个高阶函数, 返回了一个匿名函数. 第一种方式相当于直接调用那个匿名函数执行环境就是<code>window</code>, 所以<code>this</code>指向<code>window</code>; 第二种方式通过 person2 来调用 person 的高阶函数, 输出 person2; 第三种先通过 person2 调用 person 的高阶函数, 然后在全局作用域下执行, 因此<code>this</code>指向<code>window</code>.</p></li><li><p>调用 showName4()<br>最后这三组调用也是高阶函数, 不过返回的匿名函数用的箭头函数. 前两种方式也就印证了我们之前所说的<strong>箭头函数的 this 继承自父级执行上下文</strong>, 所以前两种都输出 person, 就算第二种方式后面用 call 方法来矫正也是不行的; 第三种也就是通过 person2 来调用执行的 showName4 方法, 自然也就输出 person2 啦.</p></li></ul><blockquote><h3 id="call-和-apply"><a href="#call-和-apply" class="headerlink" title="call 和 apply"></a>call 和 apply</h3><p>Function.prototype.call() 和 Function.prototype.apply() 都是非常常用的方法, 在实际开发中和 JavaScript 的设计模式中这两个方法应用广泛. 其实它们的作用是一样的, 只是有传入参数形式不同的区别.</p></blockquote><ul><li><p>apply<br>apply 方法接收两个参数: 第一个参数指定函数体中 <code>this</code>的指向; 第二个参数为一个带下标的合集(可以是数组或者类数组), 这个参数将会传递给被调用的函数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一个参数为 null 的话, 表示不改变 this 的指向</span></span><br><span class="line">fn.apply(<span class="literal">null</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure></li><li><p>call<br>call 方法的第一个参数和 apply 方法一样, 指定<code>this</code>的指向; 第二个参数不同, call 方法的第二个参数的数量不固定, 从第二参数开始一次按顺序传递给被调用的函数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line">fn.call(<span class="literal">null</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><p>在我们不关心具体有多少参数被传入函数时, 就可以使用 apply 方法一股脑推过去就行了; 当我们明确的知道有多少参数, 想一目了然的表达形参和实参的对应关系时, 那么就可以用 call 方法.</p><ul><li><p>借用其他对象的方法<br>call 和 apply 经常被用来借用其他对象的方法, 常用的就有借用<code>Array</code>的方法来操作<code>arguments</code>或者借用构造函数来实现一些类似继承的效果.</p><ol><li><p>借用构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 借用构造函数 A</span></span><br><span class="line"><span class="keyword">let</span> B = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">A.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;;</span><br><span class="line">B.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B(<span class="string">'cara'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.getName); <span class="comment">// 'cara'</span></span><br></pre></td></tr></table></figure></li><li><p>借用 Array 的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.call(<span class="built_in">arguments</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// &#123;'0': 1, '1': 2, '2': 3&#125;</span></span><br><span class="line">&#125;)(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ol></li></ul><p>借用的时候要保证两个必要条件: 1. 对象本身要可以存取属性; 2. 对象的 length 属性可读写.</p><blockquote><h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind"></a>Function.prototype.bind</h3><p>绑定函数 bind 也是可以用作矫正 <code>this</code>的指向, bind 函数会创建一个新的函数(绑定函数), 新函数和目标函数将拥有相同的函数体. 第一个参数绑定<code>this</code>的指向, 从第二参数起后面的参数将作为实参绑定到目标函数的形参.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> result = sum.bind(<span class="literal">null</span>, <span class="number">1</span>); <span class="comment">// 1 将作为实参传入 sum</span></span><br><span class="line"><span class="built_in">console</span>.log(result(<span class="number">2</span>)); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><blockquote><p>另外当 bind 返回的函数作为构造函数使用的话, 绑定的<code>this</code>将被忽略, 实参传入目标函数.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> original = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.b = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.a + x</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = <span class="keyword">new</span> (original.bind(obj, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(newObj.a); <span class="comment">// 1 =&gt; this 的指向被忽略</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.b()); <span class="comment">// 3 =&gt; 2 被传入 original</span></span><br></pre></td></tr></table></figure><p>call 和 apply 方法都是改变<code>this</code>指向后立即执行而 bind 可以在你想执行的<br>时候再执行.</p><p>差不多就到这儿吧, 要是有补充再接着写…</p><p>Created on 2017-10-17 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 JavaScript 中, &lt;code&gt;this&lt;/code&gt;关键字很容易使大家疑惑, 再加上 &lt;code&gt;Function.prototype.call&lt;/code&gt;和&lt;code&gt;Function.prototype.apply&lt;/code&gt;这两个方法的广泛运用, 所
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
      <category term="JavaScript设计模式" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 关于运算的小技巧</title>
    <link href="https://yoursite.com/2017/10/17/JavaScript-%E5%85%B3%E4%BA%8E%E8%BF%90%E7%AE%97%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://yoursite.com/2017/10/17/JavaScript-关于运算的小技巧/</id>
    <published>2017-10-17T14:10:33.000Z</published>
    <updated>2018-05-13T03:49:29.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="1-使用-操作符转换布尔值"><a href="#1-使用-操作符转换布尔值" class="headerlink" title="1. 使用 !! 操作符转换布尔值"></a>1. 使用 <code>!!</code> 操作符转换布尔值</h4><p>用于检查一个变量是否存在或者是有效值, 对变量使用 <code>!!variable</code> 来验证,<br>只要变量的值为: 0, null, undefined, NaN都将返回 false, 反之返回 true. 如: </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span> ( count ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cash = count;</span><br><span class="line">        <span class="keyword">this</span>.myCash = !!count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> emptyFoo = <span class="keyword">new</span> Foo(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.cash); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.myCash); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo.cash); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.myCash); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="2-使用-将字符串转换为数字"><a href="#2-使用-将字符串转换为数字" class="headerlink" title="2. 使用 + 将字符串转换为数字"></a>2. 使用 <code>+</code> 将字符串转换为数字</h4><p>只适合将字符串数据转换为数字, 给后台传数据的时候经常用到,<br>如果不是字符串数据会返回 NaN.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toNumber = <span class="function"><span class="params">strNumber</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> +strNumber;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log( toNumber(<span class="string">"123"</span>) ); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">console</span>.log( toNumber(<span class="string">" abc"</span>)); <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Date也可以使用</span></span><br><span class="line"><span class="built_in">console</span>.log( +<span class="keyword">new</span> <span class="built_in">Date</span>() ); <span class="comment">// 返回时间戳</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="3-并符条件"><a href="#3-并符条件" class="headerlink" title="3. 并符条件"></a>3. 并符条件</h4><p>经常用到这样的条件判断.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isConcat) &#123;</span><br><span class="line">    Login()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以简写成这样 <code>isConact &amp;&amp; Login()</code></p><h3 id="4-获取数组中的最后一个元素"><a href="#4-获取数组中的最后一个元素" class="headerlink" title="4. 获取数组中的最后一个元素"></a>4. 获取数组中的最后一个元素</h3><p><code>Array.prototype.slice (begin, end)</code> 经常用这样的方式来截取数组的元素,<br>如果不设置 end 的值, 那么默认会将数组的长度作为 end 值.<br>如果将负数作为参数的 begin 值, 就可以获取数组的最后一个元素.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log( arr.slice(<span class="number">-1</span>) ); <span class="comment">// [5]</span></span><br><span class="line">conosle.log( arr.slice(<span class="number">-2</span>) ); <span class="comment">// [4,5]</span></span><br><span class="line">以此类推</span><br></pre></td></tr></table></figure><blockquote><h4 id="5-截断数组"><a href="#5-截断数组" class="headerlink" title="5. 截断数组"></a>5. 截断数组</h4><p>用来锁定数组的长度, 删除数组中的一些元素. 比如数组一共有10个元素,<br>但我只需要前5个元素, 就可以通过 <code>array.length = 5</code> 来截断数组, 如: </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log( arr.length); <span class="comment">// 5</span></span><br><span class="line">arr.length = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log( arr.length ); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log( arr ); <span class="comment">// [1,2,3]</span></span><br></pre></td></tr></table></figure><blockquote><h4 id="6-将NodeList转换为数组"><a href="#6-将NodeList转换为数组" class="headerlink" title="6. 将NodeList转换为数组"></a>6. 将NodeList转换为数组</h4><p>如果通过 <code>doucment.querySelectorAll(&#39;p&#39;)</code> 获取元素, 它返回的是一个DOM元素的<br>数组 ( NodeList ) 对象, 但是这个数组不具有数组的功能,<br>比如 <code>push() / sort()</code> 等. 这就需要将这个 NodeList 转换为真正的数组.<br>可以使用 <code>[].slice.call( NodeList )</code> 来实现. 如:</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> els = <span class="built_in">document</span>.querySelectorAll( <span class="string">'p'</span> );</span><br><span class="line">[].slice.call( els );</span><br><span class="line">OR:</span><br><span class="line"><span class="keyword">var</span> arrElement = <span class="built_in">Array</span>.from( els );</span><br><span class="line">ES6:</span><br><span class="line"><span class="keyword">var</span> arr = [...els]</span><br></pre></td></tr></table></figure><blockquote><h4 id="7-数组元素重排"><a href="#7-数组元素重排" class="headerlink" title="7. 数组元素重排"></a>7. 数组元素重排</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(list.sort(<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="built_in">Math</span>.random() - <span class="number">0.5</span>&#125;))</span><br></pre></td></tr></table></figure></blockquote><p>Created on 2017-6-14 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;1-使用-操作符转换布尔值&quot;&gt;&lt;a href=&quot;#1-使用-操作符转换布尔值&quot; class=&quot;headerlink&quot; title=&quot;1. 使用 !! 操作符转换布尔值&quot;&gt;&lt;/a&gt;1. 使用 &lt;code&gt;!!&lt;/code&gt; 操作符转换布尔值
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title> JavaScript 模块化</title>
    <link href="https://yoursite.com/2017/10/17/JavaScript-%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://yoursite.com/2017/10/17/JavaScript-模块化/</id>
    <published>2017-10-17T13:49:59.000Z</published>
    <updated>2018-05-13T03:49:29.855Z</updated>
    
    <content type="html"><![CDATA[<p>使用函数和闭包来构造模块. 模块是一个提供接口却隐藏状态与现实的函数或对象.<br>通过模块可以摒弃全局变量的使用, 模块模式的一般形式是: 一个定义私有变量和函数的函数;<br>利用闭包创建可以访问私有变量和函数的特权函数.<br>—— &lt;&lt; JavaScript语言精粹 &gt;&gt;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> serial_maker = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 私有变量</span></span><br><span class="line"><span class="keyword">let</span> prefix = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">let</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="comment">// 特权方法</span></span><br><span class="line">set_prefix: <span class="function"><span class="params">str</span> =&gt;</span> &#123;</span><br><span class="line">prefix = <span class="built_in">String</span>(str);</span><br><span class="line">&#125;,</span><br><span class="line">set_num: <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">num = +n;</span><br><span class="line">&#125;,</span><br><span class="line">get_sum: <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> result = prefix + num;</span><br><span class="line">num++;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> seqer = serial_maker();</span><br><span class="line">seqer.set_prefix(<span class="string">'Hi'</span>);</span><br><span class="line">seqer.set_num(<span class="number">0101</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(seqer.get_sum()) <span class="comment">// 'Hi0101'</span></span><br></pre></td></tr></table></figure><h3 id="CommonJs-与-AMD"><a href="#CommonJs-与-AMD" class="headerlink" title="CommonJs 与 AMD"></a>CommonJs 与 AMD</h3><p>因为有了模块的概念, 所以我们能将很多重复性的代码封装成一个模块, 想用什么<br>功能就加载什么模块, 也能更方便是使用别人的代码. 但是这样就会要求大家都用<br>同样的方式封装模块, 所以就有了 CommonJs 和 AMD 来规范大家的写法.</p><ul><li>CommonJs<br>Node.js的模块就是参照 CommonJs 来实现的, 在服务器端是一定会用到模块的. CommonJs<br>是同步加载, 也就是说当引入一个模块必须等待该模块加载完成之后, 才会执行接下来的代码.<br>对于服务器来说所有的模块都放在本地, 所以等待的时间很短; 但对于浏览器来说, 所有的模块<br>都放在服务器, 所以等待的时间完全取决于网速, 就很容易出现假死的状态.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line"></span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>AMD<br>AMD是”Asynchronous Module Definition”的缩写, 意思就是”异步模块定义”. 它就是采用异步<br>加载, 因此模块的加载并不影响后面的语句执行. 将所有依赖于这个模块的语句都放在一个定义的回调<br>函数中执行, 这样等待模块加载完成之后就会去执行这个回调函数.</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="built_in">module</span>], callback);</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'module'</span>], <span class="built_in">module</span> =&gt; &#123;</span><br><span class="line"><span class="built_in">module</span>.increment(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="export-export-default"><a href="#export-export-default" class="headerlink" title="export / export default"></a>export / export default</h3><p>在JavaScript ES6中，export与export default均可用于导出常量/函数/文件/模块等,<br>以便在其它文件或模块中通过import将其导入使用.</p><ul><li>export<br>export 可以导出多个</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> fn = <span class="function"><span class="params">n</span> =&gt;</span> n+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 index.html 引入</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo, fn&#125; <span class="keyword">from</span> <span class="string">'types.js'</span></span><br></pre></td></tr></table></figure><ul><li>export default<br>只能导出一个</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">const</span> foo = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 index.html 引入</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">'types.js'</span></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> foo&#125; <span class="keyword">from</span> <span class="string">'types.js'</span></span><br></pre></td></tr></table></figure><p>Created on 2017-9-15 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;使用函数和闭包来构造模块. 模块是一个提供接口却隐藏状态与现实的函数或对象.&lt;br&gt;通过模块可以摒弃全局变量的使用, 模块模式的一般形式是: 一个定义私有变量和函数的函数;&lt;br&gt;利用闭包创建可以访问私有变量和函数的特权函数.&lt;br&gt;—— &amp;lt;&amp;lt; JavaScri
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Quick Sort</title>
    <link href="https://yoursite.com/2017/10/17/Quick-Sort/"/>
    <id>https://yoursite.com/2017/10/17/Quick-Sort/</id>
    <published>2017-10-17T13:42:33.000Z</published>
    <updated>2018-05-13T03:49:29.856Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序的实现, 参考资料<a href="http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html" target="_blank" rel="noopener">阮一峰</a></p><blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>快排法的思想， 分为以下三步</p><ol><li>在数据集中， 选择任意一个数据作为参照物（一般取中间位置的元素）。</li><li>所有小于参照物的元素都放在左边，大于参照物的元素都放在右边。</li><li>对左右两边的子集递归， 至到排序完成。</li></ol></blockquote><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><ul><li><p>非原地快速排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">11</span>, <span class="number">65</span>, <span class="number">23</span>, <span class="number">108</span>, <span class="number">99</span>, <span class="number">11</span>, <span class="number">55</span>, <span class="number">11</span>, <span class="number">33</span>, <span class="number">100</span>, <span class="number">108</span>, <span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'快排'</span>);</span><br><span class="line"><span class="keyword">const</span> quickSort = <span class="function"><span class="params">array</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 数组只剩一个元素时停止</span></span><br><span class="line">    <span class="keyword">if</span> (array.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> array;</span><br><span class="line">    <span class="comment">// 取参照物</span></span><br><span class="line">    <span class="keyword">let</span> pivotIndex = <span class="built_in">Math</span>.floor(array.length / <span class="number">2</span>),</span><br><span class="line">        <span class="comment">// 这里用splice删除参照物避免重复循环</span></span><br><span class="line">        pivot = array.splice(pivotIndex, <span class="number">1</span>),</span><br><span class="line">        leftArr = [],</span><br><span class="line">        rightArr = [];</span><br><span class="line">    <span class="comment">// 分区</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] &lt; pivot) &#123;</span><br><span class="line">            leftArr.push(array[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rightArr.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSort(leftArr).concat(pivot, quickSort(rightArr));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(quickSort(array)); <span class="comment">// [ 11, 11, 11, 23, 33, 55, 65, 99, 100, 100, 108, 108 ]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'快排'</span>); <span class="comment">// 4ms 左右</span></span><br></pre></td></tr></table></figure></li><li><p>原地快速排序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'快排2'</span>);</span><br><span class="line"><span class="comment">// 互换</span></span><br><span class="line"><span class="keyword">const</span> swap = <span class="function">(<span class="params">items, firstIndex, secondIndex</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = items[firstIndex];</span><br><span class="line">    items[firstIndex] = items[secondIndex];</span><br><span class="line">    items[secondIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 分区</span></span><br><span class="line"><span class="keyword">const</span> partition = <span class="function">(<span class="params">items, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pivot = items[<span class="built_in">Math</span>.floor((right + left) / <span class="number">2</span>)],</span><br><span class="line">        i = left,</span><br><span class="line">        j = right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (items[i] &lt; pivot) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (items[j] &gt; pivot) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= j) &#123;   </span><br><span class="line">            swap(items, i, j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">const</span> quickSortTwo = <span class="function">(<span class="params">items, left, right</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index;</span><br><span class="line">    <span class="keyword">if</span> (items.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        left = <span class="keyword">typeof</span> left != <span class="string">"number"</span> ? <span class="number">0</span> : left;</span><br><span class="line">        right = <span class="keyword">typeof</span> right != <span class="string">"number"</span> ? items.length - <span class="number">1</span> : right;</span><br><span class="line"></span><br><span class="line">        index = partition(items, left, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">            quickSortTwo(items, left, index - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index &lt; right) &#123;</span><br><span class="line">            quickSortTwo(items, index, right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> items;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(quickSortTwo(array));</span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'快排2'</span>);</span><br></pre></td></tr></table></figure></li><li><p>原生sort</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.time(<span class="string">'原生'</span>);</span><br><span class="line">array.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(array);</span><br><span class="line"><span class="comment">// 5ms 左右</span></span><br><span class="line"><span class="built_in">console</span>.timeEnd(<span class="string">'原生'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>三种方法， 当数组达到1W时差距就比较大了，原生需要17ms左右，原地快排需要13ms左右，而非原地快排则需要88ms左右。</p><p>Created on 2017-9-7 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;快速排序的实现, 参考资料&lt;a href=&quot;http://www.ruanyifeng.com/blog/2011/04/quicksort_in_javascript.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;阮一峰&lt;/a&gt;&lt;/p&gt;
&lt;bl
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Inheritance 继承</title>
    <link href="https://yoursite.com/2017/10/16/Inheritance-%E7%BB%A7%E6%89%BF/"/>
    <id>https://yoursite.com/2017/10/16/Inheritance-继承/</id>
    <published>2017-10-16T14:37:47.000Z</published>
    <updated>2018-05-13T03:49:29.854Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>在那些基于类的语言, 继承是一种代码重用的形式, 如果一个新的类与一个已存<br>在的类拥有大部分相同的功能, 那么就只需要说明两者之间的区别即可. 但是<br> JavaScript 并没有类的概念, 但是有很多代码重用的模式, 它可以模拟类的<br>模式, 也可以支持其他的模式.</p></blockquote><h3 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h3><p>在 C++ 和 Java中都是用 new 命令来生成示实例, 在使用 new 命令时都会调用类的<br>构造函数(constructor), 因此 Brendan Eich ( JavaScript 作者)将 new 引入了 JavaScript,<br>从原型对象上生成一个实例对象. 因为 js 没有类, 所以在 new 命令后面跟的是构造函数,<br>而不是像 Java 一样跟的是类. 简单的来说就是通过构造器生产对象.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先扩展一个方法, 懒得每次打prototype</span></span><br><span class="line"><span class="comment">// 这个不是必须的</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.method = <span class="function"><span class="keyword">function</span> (<span class="params">name, fn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.prototype[name] = fn;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语言精粹里的例子 (其实这一步就是在模仿 new 的实现)</span></span><br><span class="line"><span class="built_in">Function</span>.method(<span class="string">'new'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新对象, 它继承构造器函数的原型对象</span></span><br><span class="line"><span class="keyword">let</span> that = <span class="built_in">Object</span>.create(<span class="keyword">this</span>.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用构造器函数, 将 this 绑定到新对象上</span></span><br><span class="line"><span class="keyword">let</span> other = <span class="keyword">this</span>.apply(that, <span class="built_in">arguments</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">typeof</span> other === <span class="string">'object'</span> &amp;&amp; other) || that</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在定义一个构造器</span></span><br><span class="line"><span class="keyword">let</span> Bar = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展这个构造函数的原型</span></span><br><span class="line">Bar.prototype.get_name = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line">Bar.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.saying || <span class="string">''</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后构造一个实例</span></span><br><span class="line"><span class="keyword">let</span> myBar = <span class="keyword">new</span> Bar(<span class="string">'妲己'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myBar.get_name()) <span class="comment">// 妲己</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  掩盖掉丑陋的 prototype</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 借助一个辅助函数</span></span><br><span class="line"><span class="built_in">Function</span>.method(<span class="string">'inherit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">parent</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.prototype = <span class="keyword">new</span> parent();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新定义一个构造函数</span></span><br><span class="line"><span class="comment">// 去继承上面的 Bar</span></span><br><span class="line"><span class="keyword">let</span> Foo = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.saying = <span class="string">'wow'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里 inherit 和 method 都直接返回 this</span></span><br><span class="line"><span class="comment">// 所以可以采用联级</span></span><br><span class="line">.inherit(Bar)</span><br><span class="line">.method(<span class="string">'noise'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="keyword">this</span>.say()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>伪类模式在通过new 命令生产对象时, 会产生内存浪费. 如上面的例子, Foo 构造函数<br>就回去重复构造器 Bar 已经完成的工作.</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>在一个纯粹的原型模式中, 将摒弃类专注于对象. 基于原型的继承相比于类的<br>继承在概念上更为简单: 一个新对象可以继承一个旧对象的属性. 通过构造一个有用<br>的对象开始, 接着可以构造出更多和这个对象相似的对象.   —-&lt;JavaScript语言精粹&gt; </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 先构造一个基础对象</span></span><br><span class="line"><span class="keyword">const</span> baseObject = &#123;</span><br><span class="line">name: <span class="string">'base'</span>,</span><br><span class="line">get_name: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来构造定制化的对象</span></span><br><span class="line"><span class="keyword">let</span> myObj = <span class="built_in">Object</span>.create(baseObject);</span><br><span class="line">myObj.name = <span class="string">'wow'</span>;</span><br><span class="line">myObj.saying = <span class="string">'Hi'</span>;</span><br><span class="line">myObj.purr = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str) &#123;</span><br><span class="line">str += <span class="string">'hello'</span></span><br><span class="line">&#125;</span><br><span class="line">str += <span class="string">'world'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一种’差异化继承’, 通过制定一个新的对象, 指明它与基本对象的不同.</p><h3 id="函数化"><a href="#函数化" class="headerlink" title="函数化"></a>函数化</h3><p>以上两种继承模式都没有实现私有化, 也就是说所有的变量和方法都是公开的, 所以就<br>可以开始运用模块模式. 这个函数主要分为四个步骤:</p><ol><li><p>创建一个新的对象</p></li><li><p>定义私有属性.</p></li><li><p>给这个新对象扩充特权函数 (暴露接口)</p></li><li><p>返回这个对象</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// spec 对象包含构造器所需要的所有信息</span></span><br><span class="line"><span class="comment">// my 对象允许其他构造器分享他们的私有属性</span></span><br><span class="line"><span class="comment">// 以便在我们的构造器中使用</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">constructor</span> = (spec, my) =&gt; &#123;</span><br><span class="line"><span class="keyword">let</span> that = &#123;&#125;; <span class="comment">// 私有实例变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> my = my || &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展共享的变量和方法</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">that = 一个新对象</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 that 添加特权方法 </span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回这个对象</span></span><br><span class="line"><span class="keyword">return</span> that</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>语言精粹里的例子</p></blockquote><ol><li><p>构造器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mammal = <span class="function"><span class="params">spec</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> that = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">that.get_name = <span class="function"><span class="params">_</span> =&gt;</span> spec.name;</span><br><span class="line">that.says = <span class="function"><span class="params">_</span> =&gt;</span> spec.saying || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> that</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMammal = mammal(&#123;<span class="attr">name</span>: <span class="string">'Herb'</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>另一个构造器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> cat = <span class="function"><span class="params">spec</span> =&gt;</span>&#123;</span><br><span class="line">spec.saying = spec.saying || <span class="string">'meow'</span>;</span><br><span class="line"><span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">let</span> that = mammal(spec);</span><br><span class="line"></span><br><span class="line">that.purr = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> i, s = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (s) &#123;</span><br><span class="line">s += <span class="string">'-'</span>;</span><br><span class="line">&#125;</span><br><span class="line">s += <span class="string">'r'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;;</span><br><span class="line">that.get_name = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> that.says() + <span class="string">' '</span> + spec.name + <span class="string">' '</span> + that.says();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> that</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCat = car(&#123;<span class="attr">name</span>: <span class="string">'Henrietta'</span>&#125;);</span><br></pre></td></tr></table></figure></li></ol><h3 id="超类"><a href="#超类" class="headerlink" title="超类"></a>超类</h3><p>以上函数化的方式还不能够调用父类的方法并向父类方法传递参数. 以下是测试代码<br>在<code>语言精粹</code>的例子的基础上稍作改动, 便于自己理解:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="keyword">const</span> mammal = <span class="function"><span class="params">spec</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> that = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">that.get_name = <span class="function"><span class="params">_</span> =&gt;</span> spec.name;</span><br><span class="line">that.says = <span class="function"><span class="params">_</span> =&gt;</span> spec.saying || <span class="string">'Hi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> that</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myMammal = mammal(&#123;<span class="attr">name</span>: <span class="string">'Cara'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myMammal.says()) <span class="comment">// 'Hi'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造器2</span></span><br><span class="line"><span class="keyword">const</span> cat = <span class="function"><span class="params">spec</span> =&gt;</span> &#123;</span><br><span class="line">spec.saying = spec.saying || <span class="string">'meow'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时 that 已经包含: get_name 和 says 方法</span></span><br><span class="line"><span class="keyword">let</span> that = mammal(spec);</span><br><span class="line"></span><br><span class="line">that.purr = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (str) &#123;</span><br><span class="line">str += <span class="string">'-'</span>;</span><br><span class="line">&#125;</span><br><span class="line">str += <span class="string">'r'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str</span><br><span class="line">&#125;;</span><br><span class="line">that.get_name = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n || <span class="string">"i dont't have name"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> that</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCat = cat(&#123;<span class="attr">name</span>: <span class="string">'Henrietta'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// i dont't have name</span></span><br><span class="line"><span class="built_in">console</span>.log(myCat.get_name())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时候 cat 还不能访问父类方法的能力</span></span><br><span class="line"><span class="comment">// 所以超类 super 还是有必要的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先扩展两个方法</span></span><br><span class="line"><span class="comment">// 这个方法不能用箭头函数来定义, 否则 this 指向的window</span></span><br><span class="line"><span class="comment">// 这里 this 需要的是被调用的对象</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.method =  <span class="function"><span class="keyword">function</span> (<span class="params">name, fn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.prototype[name] = fn;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义调用父类的函数</span></span><br><span class="line"><span class="built_in">Object</span>.method(<span class="string">'superior'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> that = <span class="keyword">this</span>,</span><br><span class="line">        method = that[name];</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// this cat function</span></span><br><span class="line">    <span class="built_in">console</span>.log(n)</span><br><span class="line">        <span class="keyword">return</span> method.call(that, n);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 来试试调用父类</span></span><br><span class="line"><span class="keyword">const</span> coolCat = <span class="function"><span class="params">spec</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> that = cat(spec);</span><br><span class="line"><span class="keyword">let</span>super_get_name = that.superior(<span class="string">'get_name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// n 给父类方法传参</span></span><br><span class="line">that.get_name = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'like '</span> + super_get_name.call(<span class="keyword">this</span>, n) + <span class="string">' baby'</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> that</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCoolCat = coolCat(&#123;<span class="attr">name</span>: <span class="string">'Bix'</span>, <span class="attr">saying</span>: <span class="string">'Hi'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> name = myCoolCat.get_name(<span class="string">'this cat function'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// like this cat function baby</span></span><br></pre></td></tr></table></figure><h4 id="最后随便提一下"><a href="#最后随便提一下" class="headerlink" title="最后随便提一下"></a>最后随便提一下</h4><p>箭头函数的几个使用注意点:</p><ol><li><p>函数体内的 <code>this</code> 对象, 就是定义时所在的对象, 而不是使用时所在的对象.</p></li><li><p>不可以当作构造函数, 也就是说, 不可以使用new命令, 否则会抛出一个错误.<br>因为箭头函数没有自己的 <code>this</code>, 而是继承外层函数的<code>this</code>.</p></li><li><p>不可以使用 <code>arguments</code> 对象, 该对象在函数体内不存在.</p></li><li><p>不可以使用 <code>yield</code> 命令, 因此箭头函数不能用作Generator函数.</p></li></ol><p>Ceated on 2017-9-15 by Cara </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h1 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;p&gt;在那些基于类的语言, 继承是一种代码重用的形式, 如果一个新的类与一个已存&lt;br&gt;在的类拥有大部分相同的功能, 那
      
    
    </summary>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E5%A4%8D%E4%B9%A0/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 方法集</title>
    <link href="https://yoursite.com/2017/10/16/JavaScript-%E6%96%B9%E6%B3%95%E9%9B%86/"/>
    <id>https://yoursite.com/2017/10/16/JavaScript-方法集/</id>
    <published>2017-10-16T14:29:16.000Z</published>
    <updated>2018-05-13T03:49:29.855Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript包含了一套小型的可用在标准类型上的标准方法集,<br>主要是针对数组/正则及字符串的一些处理.</p><blockquote><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2></blockquote><h3 id="array-concat-item…"><a href="#array-concat-item…" class="headerlink" title="array.concat(item…)"></a>array.concat(item…)</h3><p>concat 方法产生一个新的数组, 它包含的是一份 array 的浅复制<br>并把参数 item 追加在其后. 如果 item 是数组, 那么这个数组的<br>每个元素都会被添加.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="keyword">let</span> result = arr.concat(arr2, <span class="string">'wow'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [1, 2, 3, 4, 5, 6, 'wow'];</span></span><br></pre></td></tr></table></figure><h3 id="array-join-separator"><a href="#array-join-separator" class="headerlink" title="array.join(separator)"></a>array.join(separator)</h3><p>join 方法是把一个 array 以指定的分隔符构造成一个字符串.<br>它先把 array 中的每个元素构造成一个字符串, 然后以指定的<br>分隔符把它们都连接起来. 默认的 separate 是逗号, 可以用<br>空字符串作为 separate.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">array.push(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = array(<span class="string">"|"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// "a|b|c|d"</span></span><br></pre></td></tr></table></figure><h3 id="array-pop"><a href="#array-pop" class="headerlink" title="array.pop()"></a>array.pop()</h3><p>pop 和 push 方法可以使 array 像堆栈一样工作. pop 方法移除数组<br>中的最后一个元素并返回该元素, 如果是空数组, 它将返回 undefined.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.pop()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h3 id="array-push-item…"><a href="#array-push-item…" class="headerlink" title="array.push(item…)"></a>array.push(item…)</h3><p>push 方法向数组的末尾添加一个或多个元素. 和 concat 方法不同的是,<br>他会修改 array, 如果 item 是一个数组, 会将整个参数数组作为一个元素<br>添加到 array 的末尾, 并返回这个新数组的长度.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = array.push(arr. <span class="string">'Hi'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result); </span><br><span class="line"><span class="comment">// array: [1, 2, 3, [4, 5, 6], 'Hi']</span></span><br><span class="line"><span class="comment">// result: 5</span></span><br></pre></td></tr></table></figure><h3 id="array-reverse"><a href="#array-reverse" class="headerlink" title="array.reverse()"></a>array.reverse()</h3><p>reverse 方法反转数组元素的顺序, 并返回数组本身.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = array.reverse();</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [3, 2, 1]</span></span><br></pre></td></tr></table></figure><h3 id="array-shift"><a href="#array-shift" class="headerlink" title="array.shift()"></a>array.shift()</h3><p>shift 方法移除数组中的第一个元素并返回该元素. 如果是空数组<br>将会返回 undefined. shift 通常比 pop 慢得多.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> result = array.shift();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="array-slice-start-end"><a href="#array-slice-start-end" class="headerlink" title="array.slice(start, end)"></a>array.slice(start, end)</h3><p>slice 方法是截取 array 中的一段做浅复制. 复制 array[start] 开始<br>到复制 array[end]为止. end 参数是可选的, 默认值的长度是 array.length.<br>如果 start 的值大于等于 array.length, 会得到一个新的空数组.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a  = array.slice(<span class="number">0</span>, <span class="number">1</span>); <span class="comment">// [1]</span></span><br><span class="line"><span class="keyword">let</span> b = array.slice(<span class="number">1</span>); <span class="comment">// [2, 3]</span></span><br><span class="line"><span class="keyword">let</span> c = array.slice(<span class="number">-1</span>); <span class="comment">// [3]</span></span><br></pre></td></tr></table></figure><h3 id="array-sort-comparefn"><a href="#array-sort-comparefn" class="headerlink" title="array.sort(comparefn)"></a>array.sort(comparefn)</h3><p>sort 方法是对数组中的元素排序，但他的默认比较函数是把被排序的元素都视为<br>字符串。 所以通常都是自己定义比较函数.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对字符串和数字排序</span></span><br><span class="line"><span class="keyword">const</span> compare = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a === b) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="keyword">typeof</span> b) &#123;</span><br><span class="line"><span class="keyword">return</span>  a &lt; b ? <span class="number">-1</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> a &lt; <span class="keyword">typeof</span> b ? <span class="number">-1</span> :<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> array = [<span class="string">'bb'</span>, <span class="string">'aa'</span>, <span class="number">2</span>, <span class="string">'cc'</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(array.sort(compare())); <span class="comment">// [ 1, 2, 3, 7, 'aa', 'bb', 'cc' ]</span></span><br></pre></td></tr></table></figure><blockquote><p>稳定性：排序后2个相等键值的顺序和排序之前它们的顺序相同.</p></blockquote><ul><li>不稳定排序</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> by = <span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// o/p 每组相比较的数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">o, p</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> a, b;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(o &amp;&amp; p &amp;&amp; <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> p === <span class="string">'object'</span>) &#123;</span><br><span class="line">a = o[name];</span><br><span class="line">b = p[name];</span><br><span class="line"><span class="comment">// 全等时</span></span><br><span class="line"><span class="keyword">if</span> (a === b) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="keyword">typeof</span> b) &#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b ? <span class="number">-1</span> : <span class="number">1</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不同类型</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> a &lt; <span class="keyword">typeof</span> b ? <span class="number">-1</span> : <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'排序失败'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = [</span><br><span class="line">&#123;<span class="attr">first</span>: <span class="string">'Joe'</span>, <span class="attr">last</span>: <span class="string">'DeRita'</span>&#125;,</span><br><span class="line">&#123;<span class="attr">first</span>: <span class="string">'Moe'</span>, <span class="attr">last</span>: <span class="string">'Howard'</span>&#125;,</span><br><span class="line">&#123;<span class="attr">first</span>: <span class="string">'Joe'</span>, <span class="attr">last</span>: <span class="string">'Besser'</span>&#125;,</span><br><span class="line">&#123;<span class="attr">first</span>: <span class="string">'Shemp'</span>, <span class="attr">last</span>: <span class="string">'Howard'</span>&#125;,</span><br><span class="line">&#123;<span class="attr">first</span>: <span class="string">'Larry'</span>, <span class="attr">last</span>: <span class="string">'Fine'</span>&#125;,</span><br><span class="line">&#123;<span class="attr">first</span>: <span class="string">'Curly'</span>, <span class="attr">last</span>: <span class="string">'Howard'</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s.sort(by(<span class="string">'first'</span>)).sort(<span class="string">'last'</span>));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[ </span></span><br><span class="line"><span class="comment">&#123; first: 'Curly', last: 'Howard' &#125;,</span></span><br><span class="line"><span class="comment">&#123; first: 'Joe', last: 'DeRita' &#125;,</span></span><br><span class="line"><span class="comment">&#123; first: 'Joe', last: 'Besser' &#125;,</span></span><br><span class="line"><span class="comment">&#123; first: 'Larry', last: 'Fine' &#125;,</span></span><br><span class="line"><span class="comment">&#123; first: 'Moe', last: 'Howard' &#125;,</span></span><br><span class="line"><span class="comment">&#123; first: 'Shemp', last: 'Howard' &#125;  </span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><ul><li>稳定排序</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让函数接收两个参数, 当第一个函数相等时</span></span><br><span class="line"><span class="comment">// 由第二个参数再次比较, 第二个次要比较函数可选</span></span><br><span class="line"><span class="keyword">const</span> betterBy = <span class="function">(<span class="params">name, minor</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function">(<span class="params">o, p</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> a, b;</span><br><span class="line"><span class="keyword">if</span> (o &amp;&amp; p &amp;&amp; <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp; <span class="keyword">typeof</span> <span class="string">'object'</span>) &#123;</span><br><span class="line">a = o[name];</span><br><span class="line">b = p[name];</span><br><span class="line"><span class="keyword">if</span> (a === b) &#123;</span><br><span class="line"><span class="comment">// 用次要比较函数再次对比</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> minor === <span class="string">'function'</span> ? minor(o, p) : <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="keyword">typeof</span> b) &#123;</span><br><span class="line"><span class="keyword">return</span> a &lt; b ? <span class="number">-1</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">typeof</span> a &lt; <span class="keyword">typeof</span> b ? <span class="number">-1</span> : <span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'排序失败'</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = [</span><br><span class="line">&#123;<span class="attr">first</span>: <span class="string">'Joe'</span>, <span class="attr">last</span>: <span class="string">'DeRita'</span>&#125;,</span><br><span class="line">&#123;<span class="attr">first</span>: <span class="string">'Moe'</span>, <span class="attr">last</span>: <span class="string">'Howard'</span>&#125;,</span><br><span class="line">&#123;<span class="attr">first</span>: <span class="string">'Joe'</span>, <span class="attr">last</span>: <span class="string">'Besser'</span>&#125;,</span><br><span class="line">&#123;<span class="attr">first</span>: <span class="string">'Shemp'</span>, <span class="attr">last</span>: <span class="string">'Howard'</span>&#125;,</span><br><span class="line">&#123;<span class="attr">first</span>: <span class="string">'Larry'</span>, <span class="attr">last</span>: <span class="string">'Fine'</span>&#125;,</span><br><span class="line">&#123;<span class="attr">first</span>: <span class="string">'Curly'</span>, <span class="attr">last</span>: <span class="string">'Howard'</span>&#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a.sort(by(<span class="string">'last'</span>,by(<span class="string">'first'</span>))));</span><br><span class="line"><span class="comment">/*[ </span></span><br><span class="line"><span class="comment">&#123; first: 'Joe', last: 'Besser' &#125;,</span></span><br><span class="line"><span class="comment">&#123; first: 'Joe', last: 'DeRita' &#125;,</span></span><br><span class="line"><span class="comment">&#123; first: 'Larry', last: 'Fine' &#125;,</span></span><br><span class="line"><span class="comment">&#123; first: 'Moe', last: 'Howard' &#125;,</span></span><br><span class="line"><span class="comment">&#123; first: 'Shemp', last: 'Howard' &#125;,</span></span><br><span class="line"><span class="comment">&#123; first: 'Curly', last: 'Howard' &#125; </span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="array-splice-start-deleteCount-item…"><a href="#array-splice-start-deleteCount-item…" class="headerlink" title="array.splice(start, deleteCount, item…)"></a>array.splice(start, deleteCount, item…)</h3><p>splice 方法从 array 中移除一个或多个元素, 并用新的 item 替换他们.<br>start 是从 array 中移除元素的开始位置 ( 索引 ) , deleteCount 是要<br>删除元素的个数, item 参数如果有会被插入到被删除元素的位置上. 返回<br>被删除的元素.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'bug'</span>];</span><br><span class="line"><span class="keyword">let</span> remove = arr.splice(<span class="number">1</span>, <span class="number">1</span>, <span class="string">'newItem'</span>, <span class="string">'Hi'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ['b', 'newItem', 'Hi','c', 'bug']</span></span><br><span class="line"><span class="built_in">console</span>.log(remove); <span class="comment">// ['a']</span></span><br></pre></td></tr></table></figure><h3 id="array-unshift-item…"><a href="#array-unshift-item…" class="headerlink" title="array.unshift(item…)"></a>array.unshift(item…)</h3><p>unshift 方法向数组的开头插入一个或多个元素并返回数组新的长度.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> insert = arr.unshift(<span class="string">'Hi'</span>, <span class="string">'d'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// ['Hi', 'd', 'a', 'b', 'c']</span></span><br><span class="line"><span class="built_in">console</span>.log(insert); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><blockquote><h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2></blockquote><h3 id="regexp-exec-string"><a href="#regexp-exec-string" class="headerlink" title="regexp.exec(string)"></a>regexp.exec(string)</h3><p>exec 方法是使用正则表达式的最强大(最慢)的方法. 如果它成功匹配<br>regexp 和字符串 string, 将返回一个数组. 数组中下标为0的元素包含<br>正则表达式 regexp 匹配的子字符串; 下标为1的元素是分组1捕获的文本;<br>下标为2的元素是分组2捕获的文本, 以此类推. 如果匹配失败则返回null.</p><h3 id="regexp-test-string"><a href="#regexp-test-string" class="headerlink" title="regexp.test(string)"></a>regexp.test(string)</h3><p>test 方法是使用正则表达式的最简单(最快)的方法. 如果该regexp 与 string<br>匹配, 它返回 true, 否则返回 false. 不要对这个方法使用 g 标识.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let b = /&amp;.+/.test(&apos;frank &amp;amp; beans&apos;);</span><br><span class="line"></span><br><span class="line">console.log(b); // true</span><br></pre></td></tr></table></figure><blockquote><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2></blockquote><h3 id="string-charAt-pos"><a href="#string-charAt-pos" class="headerlink" title="string.charAt(pos)"></a>string.charAt(pos)</h3><p>charAt 方法返回在 string 中 pos 位置处的字符串. 如果 pos 小于0或者<br>大于等于字符串的长度, 将返回空字符串.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">'Cara'</span>;</span><br><span class="line"><span class="keyword">let</span> initial = name.charAt(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(initial); <span class="comment">// 'C'</span></span><br></pre></td></tr></table></figure><h3 id="string-concat-string…"><a href="#string-concat-string…" class="headerlink" title="string.concat(string…)"></a>string.concat(string…)</h3><p>concat 方法把其他字符串连接起来返回一个新的字符串. 通常用<code>+</code></p><h3 id="string-indexOf-searchString-position"><a href="#string-indexOf-searchString-position" class="headerlink" title="string.indexOf(searchString, position)"></a>string.indexOf(searchString, position)</h3><p>indexOf 方法在 string 内查找另一个字符串 searchString. 如果被<br>找到返回第一个匹配字符串的位置, 否则返回-1. 可选参数 position<br>可设置从 string 的某个指定位置开始查找.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">'Mississippi'</span>;</span><br><span class="line"><span class="keyword">let</span> p = text.indexOf(<span class="string">'ss'</span>); <span class="comment">// 2</span></span><br><span class="line">p = text.indexOf(<span class="string">'ss'</span>, <span class="number">3</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="string-lastIndexOf-searchString-position"><a href="#string-lastIndexOf-searchString-position" class="headerlink" title="string.lastIndexOf(searchString, position)"></a>string.lastIndexOf(searchString, position)</h3><p>lastIndexOf 跟 indexOf 方法相反, 是从数组的末尾开始查找.<br>返回一个指定的字符串值最后出现的位置, 在一个字符串中的指定位置从后向前搜索.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">'Mississippi'</span>;</span><br><span class="line"><span class="keyword">let</span> p = text.lastIndexOf(<span class="string">'ss'</span>); <span class="comment">// 5</span></span><br><span class="line">p = text.lastIndexOf(<span class="string">'ss'</span>, <span class="number">3</span>); <span class="comment">// 2</span></span><br><span class="line">p = text.lastIndexOf(<span class="string">'ss'</span>, <span class="number">6</span>); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="string-match-regexp"><a href="#string-match-regexp" class="headerlink" title="string.match(regexp)"></a>string.match(regexp)</h3><p>match 方法让字符串和一个正则表达式进行匹配. 它依据<code>g</code>标识符来决定如何<br>进行匹配. 如果没有<code>g</code>标识符, 那么调用 <code>string.match(regexp)</code>的结果与<br>调用<code>regexp.exec(string)</code>的结果相同. 如果有<code>g</code>标识符, 那么它返回一个<br>包含所有匹配项(除捕获分组)的数组.</p><h3 id="string-replace-searchValue-replaceValue"><a href="#string-replace-searchValue-replaceValue" class="headerlink" title="string.replace(searchValue, replaceValue)"></a>string.replace(searchValue, replaceValue)</h3><p>replace 方法对 string 进行查找和替换操作, 并返回一个新的字符串. 参数<br>searchValue 可以是一个字符串或者一个正则表达式对象. 如果是一个字符串,<br>那么 searchValue 只会把第一次匹配的出现的地方替换掉; 如果是正则表达式<br>带有<code>g</code>标识符, 则会替换点所有匹配项.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'1-10-1001'</span>;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/-(\d+)-/</span>;</span><br><span class="line"></span><br><span class="line">str.replace(reg, <span class="string">'栋$1单元'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 1栋10单元1001</span></span><br></pre></td></tr></table></figure><h3 id="string-search-regexp"><a href="#string-search-regexp" class="headerlink" title="string.search(regexp)"></a>string.search(regexp)</h3><p>search 方法和 indexOf 方法类似, 只是它只接受一个正则表达式对象作为参数<br>而不是一个字符串. 如果找到匹配, 它返回第一个匹配的首字符位置. 如果没有<br>返回-1. 此方法会忽略<code>g</code>标识符.</p><h3 id="string-slice-start-end"><a href="#string-slice-start-end" class="headerlink" title="string.slice(start, end)"></a>string.slice(start, end)</h3><p>slice 方法复制 string 的一部分构造成一个新的字符串. 如果 start 参数是负数<br>, 他将与 string.length 相加. end 参数是可选的, 默认是 string.length. 如果<br>end 参数是负数, 也会与 string.length 相加. end 参数等于你想取的最后一个字符<br>的位置加1.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// str.length == 39</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'and in it he says "Any damn fool could'</span>;</span><br><span class="line"><span class="keyword">let</span> a = str.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 'and'</span></span><br><span class="line"><span class="keyword">let</span> b = str.slice(<span class="number">-5</span>); <span class="comment">// 'could'</span></span><br></pre></td></tr></table></figure><h3 id="string-split-separator-limit"><a href="#string-split-separator-limit" class="headerlink" title="string.split(separator, limit)"></a>string.split(separator, limit)</h3><p>split 方法把 string 以指定的分隔符构造成一个字符串数组. 可选参数<br>limit 可以限制被分割片段的数量. separator 可以是一个字符串或者一个<br>正则表达式. 此方法会忽略<code>g</code>标识符.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">'0123456789'</span>;</span><br><span class="line"><span class="keyword">let</span> a = str.split(<span class="string">''</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// ['0', '1', '2', '3', '4']</span></span><br></pre></td></tr></table></figure><h3 id="string-substring-start-end"><a href="#string-substring-start-end" class="headerlink" title="string.substring(start, end)"></a>string.substring(start, end)</h3><p>substring 方法和<code>slice</code> 方法一样, 只是不能处理负数. 所以用<code>slice</code>代替它</p><h3 id="string-toLocaleLowerCase"><a href="#string-toLocaleLowerCase" class="headerlink" title="string.toLocaleLowerCase()"></a>string.toLocaleLowerCase()</h3><p>toLocaleLowerCase 方法返回一个新的字符串, 它使用本地化的规则把这个 string<br>中的所有字母转换为小写格式.</p><h3 id="string-toLocaleUpperCase"><a href="#string-toLocaleUpperCase" class="headerlink" title="string.toLocaleUpperCase()"></a>string.toLocaleUpperCase()</h3><p>toLocaleUpperCase 方法返回一个新的字符串, 它使用本地化的规则把这个 string<br>中的所有字母转换为大写格式.</p><p>Created on 17/9/21 by Cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JavaScript包含了一套小型的可用在标准类型上的标准方法集,&lt;br&gt;主要是针对数组/正则及字符串的一些处理.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;Array&quot;&gt;&lt;a href=&quot;#Array&quot; class=&quot;headerlink&quot; title=&quot;Arra
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
      <category term="复习" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 深浅拷贝</title>
    <link href="https://yoursite.com/2017/10/16/JavaScript-%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>https://yoursite.com/2017/10/16/JavaScript-深浅拷贝/</id>
    <published>2017-10-16T13:45:01.000Z</published>
    <updated>2018-05-13T03:49:29.855Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝只能拷贝顶层属性基本数据类型, 也就是如果父对象的属性是一个对象或数组, 那么子对象获取到的只是一个内存地址而不是一个真正的对象, 所以一旦修改父对象也会跟着被篡改.</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shallowCopy</span> (<span class="params"> parent </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> parent) &#123;</span><br><span class="line">         o[i] = parent[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝也就是能够实现数组和对象拷贝, 深拷贝与浅拷贝对比, 深拷贝会在堆区开辟新的一块来储存新的对象. 两个对象对应的是两个不同的内存地址, 所以修改其中一个对象的属性并不会影响到另一个对象的属性. 实现深拷贝也有两种方式: 一种是递归/ 一种是JSON.</p></blockquote><ol><li><p>递归</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span> (<span class="params">parent, child = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> parent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> parent[i] === <span class="string">'object'</span>) &#123;</span><br><span class="line">            child[i] = (parent[i].constructor == <span class="built_in">Array</span>) ? [] : &#123;&#125;;</span><br><span class="line">            deepCopy(parent[i], child[i])</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             child[i] = parent[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JSON解析(严格的 JSON 格式)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    age: <span class="string">'18'</span>,</span><br><span class="line">    friends: [<span class="string">'老张'</span>, <span class="string">'老王'</span>],</span><br><span class="line">    job: &#123;</span><br><span class="line">       main: <span class="string">'睡觉'</span>,</span><br><span class="line">       sub: <span class="string">'躺着'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> result = <span class="built_in">JSON</span>.parse( <span class="built_in">JSON</span>.stringify(o));</span><br><span class="line">result.name = <span class="string">'cara'</span>;</span><br><span class="line">result.friends.push(<span class="string">'老李'</span>);</span><br><span class="line"><span class="built_in">console</span>.dir(o);</span><br><span class="line"><span class="built_in">console</span>.dir(result)</span><br></pre></td></tr></table></figure></li></ol><p>以上两种方式无法解析一下几种情况:</p><ul><li>RegExp 对象</li><li>函数</li><li>会摒弃对象的 constructor , 所有构造函数都会指向 Object</li><li>对象循环引用也会报错</li></ul><p>所以要面对不同的对象, 做不同的处理方式, 就需要检查一下对象的类型:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查类型</span></span><br><span class="line"><span class="keyword">const</span> Type = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> Types = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, type; type = [<span class="string">'Array'</span>, <span class="string">'Date'</span>, <span class="string">'RegExp'</span>][i++];) &#123;</span><br><span class="line">        Types[<span class="string">'is'</span> + type] = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Types</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> types = Type()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取正则影响范围</span></span><br><span class="line"><span class="keyword">const</span> getRegExp = <span class="function">(<span class="params">reg</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (reg.globlal) <span class="keyword">return</span> <span class="string">'g'</span></span><br><span class="line">    <span class="keyword">if</span> (reg.ignoreCase) <span class="keyword">return</span> <span class="string">'i'</span></span><br><span class="line">    <span class="keyword">if</span> (reg.multiline) <span class="keyword">return</span> <span class="string">'m'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clone = <span class="function">(<span class="params">oldObj = &#123;&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> oldObjs = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> _clone = <span class="function"><span class="params">oldObj</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> newObj, proto</span><br><span class="line">        <span class="comment">// 不同类型, 不同处理方式</span></span><br><span class="line">        <span class="keyword">if</span> (types.isArray(oldObj)) &#123;</span><br><span class="line">            newObj = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (types.isDate(oldObj)) &#123;</span><br><span class="line">            newObj = <span class="keyword">new</span> <span class="built_in">Date</span>(oldObj.getTime())</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (types.isRegExp(oldObj)) &#123;</span><br><span class="line">            newObj = <span class="keyword">new</span> <span class="built_in">RegExp</span>(oldObj.source, getRegExp(oldObj))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 斩断原型链</span></span><br><span class="line">            proto = <span class="built_in">Object</span>.getPrototypeOf(oldObj)</span><br><span class="line">            newObj = <span class="built_in">Object</span>.create(proto)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果之前已经遍历过该对象, 直接返回该对象</span></span><br><span class="line">        <span class="keyword">let</span> hasBeen = oldObjs.indexOf(oldObj)</span><br><span class="line">        <span class="keyword">if</span> (hasBeen !== <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> oldObjs[hasBeen]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录操作过的对象</span></span><br><span class="line">        oldObjs.push(oldObj)</span><br><span class="line">        <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> oldObj) &#123;</span><br><span class="line">            newObj[i] = _clone(oldObj[i])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newObj</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _clone(oldObj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>👇测试一波:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Cara = <span class="keyword">new</span> person(<span class="string">'Cara'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello world!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> oldObj = &#123;</span><br><span class="line">    a: say,</span><br><span class="line">    c: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ab+c'</span>, <span class="string">'i'</span>),</span><br><span class="line">    d: Cara,</span><br><span class="line">&#125;;</span><br><span class="line">oldObj.b = oldObj;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = clone(oldObj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(newObj.a, oldObj.a) </span><br><span class="line"><span class="comment">// [Function: say] [Function: say]</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.b, oldObj.b)</span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//     a: [Function: say], </span></span><br><span class="line"><span class="comment">//     c: /ab+c/i, </span></span><br><span class="line"><span class="comment">//     d: person &#123; name: 'Messi' &#125;, </span></span><br><span class="line"><span class="comment">//     b: [Circular] </span></span><br><span class="line"><span class="comment">// &#125; </span></span><br><span class="line"><span class="comment">// &#123; </span></span><br><span class="line"><span class="comment">//     a: [Function: say], </span></span><br><span class="line"><span class="comment">//     c: /ab+c/i, </span></span><br><span class="line"><span class="comment">//     d: person &#123; name: 'Messi' &#125;, </span></span><br><span class="line"><span class="comment">//     b: [Circular] </span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.c, oldObj.c)</span><br><span class="line"><span class="comment">// /ab+c/i /ab+c/i</span></span><br><span class="line"><span class="built_in">console</span>.log(newObj.d.constructor, oldObj.d.constructor)</span><br><span class="line"><span class="comment">// [Function: person][Function: person]</span></span><br></pre></td></tr></table></figure></p><p>目前我们上面说的几种坑就得以解决, 不过这还不是最完整的方案, 还有一些 ES6 里面的对象也需要我们做特殊的处理, 不过现在这个版本在日常还是够用了. 另外在生产环境中还是建议用 <code>lodash</code> 的 <code>_.cloneDeep</code></p><p>Created on 2017-8-15 by cara</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h3 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷贝&lt;/h3&gt;&lt;p&gt;浅拷贝只能拷贝顶层属性基本数据类型, 也就是如果父对象的属性是一个对象或数组, 那么子对象获取到的只是一个
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>3D-Tags</title>
    <link href="https://yoursite.com/2017/10/15/3D-Tags/"/>
    <id>https://yoursite.com/2017/10/15/3D-Tags/</id>
    <published>2017-10-15T10:25:44.000Z</published>
    <updated>2018-05-13T03:49:29.853Z</updated>
    
    <content type="html"><![CDATA[<p>3D 标签云<br>练习canvas的3D效果,  球体算法, 正好IFE 的项目有就记录一下咯.</p><h3 id="大概思路"><a href="#大概思路" class="headerlink" title="大概思路"></a>大概思路</h3><p>首先3D云其实就是一个球体, 在这个球体上平均分布各个点, 再把这些点<br>的坐标赋给标签,计算一下 z 轴的大小, 最后通过改变字体的大小/ 透明度<br>就可以模拟出立体的效果啦.</p><h3 id="相关的一些公式及说明"><a href="#相关的一些公式及说明" class="headerlink" title="相关的一些公式及说明"></a>相关的一些公式及说明</h3><ol><li>球体 x/ y/ z 轴的坐标点<br>已知半径 R 和球心, 方便起见一般都以坐标轴的原点作为球心. 有如下三个方程式:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = R * sinθ * cosø</span><br><span class="line">y = R * sinθ * sinø</span><br><span class="line">z = R * cosθ</span><br></pre></td></tr></table></figure></li></ol><p>其中θ 和 ø 可以去随机数, 来获取圆上的随机点坐标. 但是3D 云的坐标点是需要均匀分配的坐标点, 所以光是去随机点是不够的. 所以又有了下面的公式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index 为当前索引, length 为标签长度</span></span><br><span class="line"><span class="comment">// 这段我也不懂原理是什么, 在别人的代码里看见的...</span></span><br><span class="line">θ = acos((<span class="number">2</span> * (index + <span class="number">1</span>) - <span class="number">1</span>) / length - <span class="number">1</span>)</span><br><span class="line"><span class="comment">// n 取 Math.PI</span></span><br><span class="line">ø = θ * sqrt(length * n)</span><br></pre></td></tr></table></figure><h4 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setBall = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 标签</span></span><br><span class="line"><span class="keyword">let</span> tagLabel = <span class="built_in">document</span>.querySelector(<span class="string">'.tag'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i =<span class="number">0</span>, len = tagLabel.length; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> k = (<span class="number">2</span> * (i + <span class="number">1</span>) - <span class="number">1</span>) / len - <span class="number">1</span>,</span><br><span class="line">a = acos(k), <span class="comment">// 上述θ </span></span><br><span class="line">b = a * sqrt(len * <span class="built_in">Math</span>.PI), <span class="comment">// 上述ø</span></span><br><span class="line">x = radius * <span class="built_in">Math</span>.sin(a) * <span class="built_in">Math</span>.cos(b), </span><br><span class="line">y = radius * <span class="built_in">Math</span>.sin(a) * <span class="built_in">Math</span>.sin(b),</span><br><span class="line">z = radius * <span class="built_in">Math</span>.cos(a);</span><br><span class="line"><span class="comment">// 让球体动起来, 我们先把方法放在这儿</span></span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> tag(tagLabel[i], x, y, z);</span><br><span class="line">tags.push(t);</span><br><span class="line">t.move()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就可以取得球体所需的平均坐标点, 接下来我们就需要去操作 DOM 每个标签了.</p><ol start="2"><li>标签字体及透明度计算<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fallLength 为焦距</span></span><br><span class="line"><span class="keyword">let</span> scale = fallLength/ (fallLength - <span class="keyword">this</span>.z),</span><br><span class="line">  opa = (<span class="keyword">this</span>.z + radius) / (<span class="number">2</span> * radius);</span><br><span class="line"><span class="comment">// 每个标签添加样式</span></span><br><span class="line"><span class="keyword">this</span>.element.style.cssText = <span class="string">`color: rgb(</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">255</span>)&#125;</span>, </span></span><br><span class="line"><span class="string"><span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">255</span>)&#125;</span>, </span></span><br><span class="line"><span class="string"><span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">255</span>)&#125;</span>);</span></span><br><span class="line"><span class="string">font-size: <span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="number">15</span> * scale)&#125;</span>px;</span></span><br><span class="line"><span class="string">opacity: <span class="subst">$&#123;opa + <span class="number">0.5</span>&#125;</span>;</span></span><br><span class="line"><span class="string">z-index: <span class="subst">$&#123;<span class="built_in">parseInt</span>(scale * <span class="number">100</span>)&#125;</span>;</span></span><br><span class="line"><span class="string">left: <span class="subst">$&#123;<span class="keyword">this</span>.x + CX - <span class="keyword">this</span>.element.offsetWidth <span class="regexp">/ 2&#125;px;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">top: $&#123;this.y + CY - this.element.offsetHeight /</span> <span class="number">2</span>&#125;</span>px`</span>;</span><br></pre></td></tr></table></figure></li></ol><p>fallLength 是焦距, 也是一个常量, scale 和 opacity 都要通过 z 轴来调整的. 这里也是从别人的代码里看到的, 应该也是公式吧; 后面就是调整字体大小/ 透明度, 标签位置的操作了. 以上计算就是<code>move()</code>函数中的内容. 现在球体已经出来了, 那么就该让他动起来了.</p><ol start="3"><li>旋转算法<br>为了让球体动起来, 我们需要知道下面这三个公式: </li></ol><p><img src="http://orf90agxq.bkt.clouddn.com/3d_tags/rotate.png" alt="旋转公式"></p><p>然后我们需要两个函数, x 轴选择和 y 轴旋转, 关键代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rotateX = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// angleX 是事先定义好的角度值</span></span><br><span class="line"><span class="keyword">let</span> sin = <span class="built_in">Math</span>.sin(angleX),</span><br><span class="line">cos = <span class="built_in">Math</span>.cos(angleX);</span><br><span class="line">tags.forEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> y1 = <span class="keyword">this</span>.y * cos - <span class="keyword">this</span>.z * sin,</span><br><span class="line">z1 = <span class="keyword">this</span>.z * cos + <span class="keyword">this</span>.y * sin;</span><br><span class="line"><span class="keyword">this</span>.y = y1;</span><br><span class="line"><span class="keyword">this</span>.z = z1;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rotateY = <span class="function"><span class="params">_</span> =&gt;</span>&#123;</span><br><span class="line"><span class="comment">// angleY 是事先定义好的角度值</span></span><br><span class="line"><span class="keyword">let</span> cos = <span class="built_in">Math</span>.cos(angleY),</span><br><span class="line">     sin = <span class="built_in">Math</span>.sin(angleY);</span><br><span class="line">tags.forEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> x1 = <span class="keyword">this</span>.x * cos - <span class="keyword">this</span>.z * sin,</span><br><span class="line">z1 = <span class="keyword">this</span>.z * cos + <span class="keyword">this</span>.x * sin;</span><br><span class="line"><span class="keyword">this</span>.x = x1;</span><br><span class="line"><span class="keyword">this</span>.z = z1;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里 angleX 和 angleY 为角度值, 用来控制标签云的旋转方向和速度. 角度的正负值控制旋转方向; 大小控制旋转速度.</p><ol start="4"><li>鼠标控制<br>这里就是最后一步了, 通过鼠标改变球体的旋转方向. 这里我做了一点点扩展几个输入框, 可以让用户自由填写云内容/ 数量及旋转速度, 下面直接看代码吧.</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 来个事件监听</span></span><br><span class="line"><span class="keyword">const</span> addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">element, event, fn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">element.addEventListener(event, fn, <span class="literal">false</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">element.attachEvent(<span class="string">'on'</span> + event, fn)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">element[<span class="string">'on'</span> + event] = fn</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户输入标签</span></span><br><span class="line">addEvent(content, <span class="string">'blur'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!!<span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">this</span>.value)</span><br><span class="line">data = <span class="keyword">this</span>.value.split(<span class="string">','</span>);</span><br><span class="line">createLabel(data, num);</span><br><span class="line"><span class="keyword">let</span> item = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.tag'</span>);</span><br><span class="line">setBall(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户输入数量</span></span><br><span class="line">addEvent(numberLabel, <span class="string">'blur'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (+<span class="keyword">this</span>.value &lt; <span class="number">0</span> || +<span class="keyword">this</span>.value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">alert(<span class="string">'请填写11 - 200之间的数值'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">num = +<span class="keyword">this</span>.value;</span><br><span class="line">createLabel(data, num);</span><br><span class="line"><span class="keyword">let</span> item = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.tag'</span>);</span><br><span class="line">setBall(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取转速</span></span><br><span class="line">addEvent(speedLabel, <span class="string">'blur'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (+<span class="keyword">this</span>.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">alert(<span class="string">'请输入大于0的数值'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">speed = +<span class="keyword">this</span>.value;</span><br><span class="line">clearInterval(interval)</span><br><span class="line">animate()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移动</span></span><br><span class="line">addEvent(container, <span class="string">"mousemove"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line"><span class="comment">// EX: 宽度的一半; CX: 左边距</span></span><br><span class="line"><span class="comment">// EY: 高度的一半; CY: 上边距</span></span><br><span class="line"><span class="keyword">var</span> x = e.clientX - EX - CX;</span><br><span class="line">  <span class="keyword">var</span> y = e.clientY - EY - CY;</span><br><span class="line">  angleX = y * <span class="number">0.0001</span>;</span><br><span class="line">  angleY = x * <span class="number">0.0001</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>到这里3D 云的流程差不多就走完了, 下面放一个完整的 js 部分代码吧.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">global</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> speedLabel = <span class="built_in">document</span>.getElementById(<span class="string">'speed'</span>),</span><br><span class="line">numberLabel = <span class="built_in">document</span>.getElementById(<span class="string">'number'</span>),</span><br><span class="line">data = [<span class="string">"JavaScript"</span>, <span class="string">"Node.Js"</span>, <span class="string">"HTML"</span>, <span class="string">"CSS"</span>, <span class="string">"vue"</span>, <span class="string">"react"</span></span><br><span class="line">, <span class="string">"JQuery"</span>, <span class="string">"Webpack"</span>, <span class="string">"Babel"</span>, <span class="string">"ES6"</span>, <span class="string">"WebSocket"</span>],</span><br><span class="line">container = <span class="built_in">document</span>.querySelector(<span class="string">'.container'</span>),</span><br><span class="line">content = <span class="built_in">document</span>.getElementById(<span class="string">'content'</span>),</span><br><span class="line">interval,</span><br><span class="line">speed = <span class="number">100</span>,</span><br><span class="line">num = <span class="number">120</span>,</span><br><span class="line">radius = <span class="number">300</span>,</span><br><span class="line">fallLength = <span class="number">500</span>,</span><br><span class="line">angleX = <span class="built_in">Math</span>.PI / <span class="number">500</span>,</span><br><span class="line">angleY = <span class="built_in">Math</span>.PI / <span class="number">500</span>,</span><br><span class="line">CX = container.offsetWidth / <span class="number">2</span>,</span><br><span class="line">CY = container.offsetHeight / <span class="number">2</span>,</span><br><span class="line">EX = container.offsetLeft,</span><br><span class="line">EY = container.offsetTop;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建标签</span></span><br><span class="line"><span class="keyword">const</span> createLabel = <span class="function">(<span class="params">data, num</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> html = <span class="string">''</span>, index;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">index = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * data.length);</span><br><span class="line">html += <span class="string">`&lt;label class='tag'&gt;<span class="subst">$&#123;data[index]&#125;</span>&lt;/label&gt;`</span>;</span><br><span class="line">&#125;</span><br><span class="line">container.innerHTML = html;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件监听</span></span><br><span class="line"><span class="keyword">const</span> addEvent = <span class="function"><span class="keyword">function</span> (<span class="params">element, event, fn</span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (element.addEventListener) &#123;</span><br><span class="line">element.addEventListener(event, fn, <span class="literal">false</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (element.attachEvent) &#123;</span><br><span class="line">element.attachEvent(<span class="string">'on'</span> + event, fn)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">element[<span class="string">'on'</span> + event] = fn</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户输入标签</span></span><br><span class="line">addEvent(content, <span class="string">'blur'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!!<span class="keyword">this</span>.value) &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">this</span>.value)</span><br><span class="line">data = <span class="keyword">this</span>.value.split(<span class="string">','</span>);</span><br><span class="line">createLabel(data, num);</span><br><span class="line"><span class="keyword">let</span> item = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.tag'</span>);</span><br><span class="line">setBall(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户输入数量</span></span><br><span class="line">addEvent(numberLabel, <span class="string">'blur'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (+<span class="keyword">this</span>.value &lt; <span class="number">0</span> || +<span class="keyword">this</span>.value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">alert(<span class="string">'请填写11 - 200之间的数值'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">num = +<span class="keyword">this</span>.value;</span><br><span class="line">createLabel(data, num);</span><br><span class="line"><span class="keyword">let</span> item = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.tag'</span>);</span><br><span class="line">setBall(item)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取转速</span></span><br><span class="line">addEvent(speedLabel, <span class="string">'blur'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (+<span class="keyword">this</span>.value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">alert(<span class="string">'请输入大于0的数值'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">speed = +<span class="keyword">this</span>.value;</span><br><span class="line">clearInterval(interval)</span><br><span class="line">animate()</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tags = [];</span><br><span class="line"></span><br><span class="line"><span class="comment">// setBall</span></span><br><span class="line"><span class="keyword">const</span> setBall = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> tagLabel = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.tag'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; tagLabel.length; i++) &#123;</span><br><span class="line"><span class="keyword">let</span> k = (<span class="number">2</span> * (i + <span class="number">1</span>) - <span class="number">1</span>) / tagLabel.length - <span class="number">1</span>,</span><br><span class="line">a = <span class="built_in">Math</span>.acos(k), <span class="comment">// 反余弦</span></span><br><span class="line">b = a * <span class="built_in">Math</span>.sqrt(tagLabel.length * <span class="built_in">Math</span>.PI), <span class="comment">// 平方根</span></span><br><span class="line">x = radius * <span class="built_in">Math</span>.sin(a) * <span class="built_in">Math</span>.cos(b),</span><br><span class="line">y = radius * <span class="built_in">Math</span>.sin(a) * <span class="built_in">Math</span>.sin(b),</span><br><span class="line">z = radius * <span class="built_in">Math</span>.cos(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> tag(tagLabel[i], x, y, z);</span><br><span class="line">tags.push(t);</span><br><span class="line">t.move()</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.forEach = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">            callback.call(<span class="keyword">this</span>[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span> (<span class="params">el, x, y, z</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.element = el;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line"><span class="keyword">this</span>.y = y;</span><br><span class="line"><span class="keyword">this</span>.z = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag.prototype = &#123;</span><br><span class="line">move: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> scale = fallLength/ (fallLength - <span class="keyword">this</span>.z),</span><br><span class="line">opa = (<span class="keyword">this</span>.z + radius) / (<span class="number">2</span> * radius);</span><br><span class="line"><span class="keyword">this</span>.element.style.cssText = <span class="string">`color: rgb(<span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">255</span>)&#125;</span>, </span></span><br><span class="line"><span class="string"><span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">255</span>)&#125;</span>, <span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">255</span>)&#125;</span>);</span></span><br><span class="line"><span class="string">font-size: <span class="subst">$&#123;<span class="built_in">parseInt</span>(<span class="number">15</span> * scale)&#125;</span>px;</span></span><br><span class="line"><span class="string">opacity: <span class="subst">$&#123;opa + <span class="number">0.5</span>&#125;</span>;</span></span><br><span class="line"><span class="string">z-index: <span class="subst">$&#123;<span class="built_in">parseInt</span>(scale * <span class="number">100</span>)&#125;</span>;</span></span><br><span class="line"><span class="string">left: <span class="subst">$&#123;<span class="keyword">this</span>.x + CX - <span class="keyword">this</span>.element.offsetWidth <span class="regexp">/ 2&#125;px;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="regexp">top: $&#123;this.y + CY - this.element.offsetHeight /</span> <span class="number">2</span>&#125;</span>px`</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> animate = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">interval = setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">rotateX();</span><br><span class="line">rotateY();</span><br><span class="line">tags.forEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.move()</span><br><span class="line">&#125;)</span><br><span class="line">&#125;, speed)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rotateX = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> sin = <span class="built_in">Math</span>.sin(angleX),</span><br><span class="line">cos = <span class="built_in">Math</span>.cos(angleX);</span><br><span class="line">tags.forEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> y1 = <span class="keyword">this</span>.y * cos - <span class="keyword">this</span>.z * sin,</span><br><span class="line">z1 = <span class="keyword">this</span>.z * cos + <span class="keyword">this</span>.y * sin;</span><br><span class="line"><span class="keyword">this</span>.y = y1;</span><br><span class="line"><span class="keyword">this</span>.z = z1;</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rotateY = <span class="function"><span class="params">_</span> =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">var</span> cos = <span class="built_in">Math</span>.cos(angleY),</span><br><span class="line">        sin = <span class="built_in">Math</span>.sin(angleY);</span><br><span class="line">        tags.forEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> x1 = <span class="keyword">this</span>.x * cos - <span class="keyword">this</span>.z * sin;</span><br><span class="line">            <span class="keyword">var</span> z1 = <span class="keyword">this</span>.z * cos + <span class="keyword">this</span>.x * sin;</span><br><span class="line">            <span class="keyword">this</span>.x = x1;</span><br><span class="line">            <span class="keyword">this</span>.z = z1;</span><br><span class="line">        &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 鼠标移动</span></span><br><span class="line">addEvent(container, <span class="string">"mousemove"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> x = e.clientX - EX - CX;</span><br><span class="line">        <span class="keyword">var</span> y = e.clientY - EY - CY;</span><br><span class="line">        angleX = y * <span class="number">0.0001</span>;</span><br><span class="line">        angleY = x * <span class="number">0.0001</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">createLabel(data, num);</span><br><span class="line"><span class="keyword">var</span> tagLabel = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.tag'</span>);</span><br><span class="line">setBall(tagLabel);</span><br><span class="line">animate()</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><p>Created on 17-10-8 by Cara<br><a href="https://caraws.github.io/IFE/IFE2017/3d-tags/index.html" target="_blank" rel="noopener">在线预览 demo</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;3D 标签云&lt;br&gt;练习canvas的3D效果,  球体算法, 正好IFE 的项目有就记录一下咯.&lt;/p&gt;
&lt;h3 id=&quot;大概思路&quot;&gt;&lt;a href=&quot;#大概思路&quot; class=&quot;headerlink&quot; title=&quot;大概思路&quot;&gt;&lt;/a&gt;大概思路&lt;/h3&gt;&lt;p&gt;首先3D云
      
    
    </summary>
    
      <category term="笔记📒" scheme="https://yoursite.com/categories/%E7%AC%94%E8%AE%B0%F0%9F%93%92/"/>
    
    
      <category term="JavaScript" scheme="https://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
